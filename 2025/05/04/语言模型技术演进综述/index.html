<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>语言模型技术演讲综述：从N-gram到BERT | 15H</title><meta name="author" content="15H"><meta name="copyright" content="15H"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="语言模型语言模型是一种通过学习大量文本数据来理解、生成或预测自然语言的模型。核心目标是学习语言的结构和模式，并根据上下文预测下一个单词或生成合理的文本内容。通俗来讲，就是计算词序列（短语、句子、段落）概率分布的一种模型，这个概率表明了这句话的合理程度，即符合人类语言规则的程度。 用数学语言描述：给定一$n$个词组成的句子$S&#x3D;w_1,w_2,\dots,w_n$，根据上下计算下一个词的概">
<meta property="og:type" content="article">
<meta property="og:title" content="语言模型技术演讲综述：从N-gram到BERT">
<meta property="og:url" content="https://blog.bayh.top/2025/05/04/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E7%BB%BC%E8%BF%B0/index.html">
<meta property="og:site_name" content="15H">
<meta property="og:description" content="语言模型语言模型是一种通过学习大量文本数据来理解、生成或预测自然语言的模型。核心目标是学习语言的结构和模式，并根据上下文预测下一个单词或生成合理的文本内容。通俗来讲，就是计算词序列（短语、句子、段落）概率分布的一种模型，这个概率表明了这句话的合理程度，即符合人类语言规则的程度。 用数学语言描述：给定一$n$个词组成的句子$S&#x3D;w_1,w_2,\dots,w_n$，根据上下计算下一个词的概">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.bayh.top/img/avatar.jpg">
<meta property="article:published_time" content="2025-05-04T10:28:34.352Z">
<meta property="article:modified_time" content="2025-05-04T13:49:08.466Z">
<meta property="article:author" content="15H">
<meta property="article:tag" content="SLM">
<meta property="article:tag" content="NNLM">
<meta property="article:tag" content="N-gram">
<meta property="article:tag" content="Transformer">
<meta property="article:tag" content="PLM">
<meta property="article:tag" content="ELMo">
<meta property="article:tag" content="BERT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.bayh.top/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "语言模型技术演讲综述：从N-gram到BERT",
  "url": "https://blog.bayh.top/2025/05/04/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E7%BB%BC%E8%BF%B0/",
  "image": "https://blog.bayh.top/img/avatar.jpg",
  "datePublished": "2025-05-04T10:28:34.352Z",
  "dateModified": "2025-05-04T13:49:08.466Z",
  "author": [
    {
      "@type": "Person",
      "name": "15H",
      "url": "https://blog.bayh.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.bayh.top/2025/05/04/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E7%BB%BC%E8%BF%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '语言模型技术演讲综述：从N-gram到BERT',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">15H</span></a><a class="nav-page-title" href="/"><span class="site-name">语言模型技术演讲综述：从N-gram到BERT</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">语言模型技术演讲综述：从N-gram到BERT</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-04T10:28:34.352Z" title="发表于 2025-05-04 18:28:34">2025-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-04T13:49:08.466Z" title="更新于 2025-05-04 21:49:08">2025-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/">自然语言处理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>语言模型是一种通过学习大量文本数据来理解、生成或预测自然语言的模型。核心目标是学习语言的结构和模式，并根据上下文预测下一个单词或生成合理的文本内容。通俗来讲，就是计算词序列（短语、句子、段落）概率分布的一种模型，这个概率表明了这句话的合理程度，即符合人类语言规则的程度。</p>
<p>用数学语言描述：给定一$n$个词组成的句子$S&#x3D;w_1,w_2,\dots,w_n$，根据上下计算下一个词的概率$P(w_n|w_1,w_2,\dots,w_{n-1})$，或计算整个句子的概率$P(S)&#x3D;P(w_1,w_2,\dots,w_n)$，$P(S)$表示语言中句子的分布概率。</p>
<p>语言模型的发展历程可以清晰地划分为三个主要阶段：早期的统计语言模型、随后出现的神经网络语言模型，以及今年来基于Tansformer架构的预训练语言模型。</p>
<h3 id="统计语言模型"><a href="#统计语言模型" class="headerlink" title="统计语言模型"></a>统计语言模型</h3><p><a target="_blank" rel="noopener" href="https://www.jsjkx.com/CN/article/openArticlePDF.jsp?id=15124">统计语言模型综述——论文地址</a></p>
<p>利用大型计算机和大规模的文本语料库进行<strong>统计建模</strong>，分析词语之间的搭配和出现频率，从而推导出词语的概率分布。</p>
<p>基本思想就是计算<strong>条件概率</strong>，利用条件概率乘法公式的推广，将句子的分布概率$P(S)$进行如下表示<br>$$<br>\begin{aligned}<br>P(S)&amp;&#x3D;P(w_1,w_2,\dots,w_n)&#x3D;P(w_1)P(w_2|w_1)P(w_3|w_2,w_1)\dots P(w_n|w_1,w_2,\dots w_{n-1}) \<br>&amp;&#x3D;\prod P(w_i|w_1,w_2,\dots,w_{i-1})<br>\end{aligned}<br>$$<br>一个句子理解成$n$个单词出现的组合，且第$i$个单词依赖于前$i-1$个单词。根据语料库中词语之间的出现频率，对下一个词的预测可以表示为<br>$$<br>P(w_i|w_1,w_2,\dots,w_i-1)&#x3D;\frac{count(w_1,w_2,w_3,\dots,w_i)}{count(w_1,w_2,\dots,w_{i-1})}<br>$$<br>但是，随着词汇量的增大，要想计算各词语之间的出现频率十分复杂，于是乎演化出了<strong>N-gram语言模型</strong>。</p>
<h4 id="N-gram"><a href="#N-gram" class="headerlink" title="N-gram"></a>N-gram</h4><p>引入马尔可夫假设，一阶的马尔可夫模型认为任意一个词$w_i$的出现概率仅与前一个词$w_{i-1}$相关。推广到N-1阶马尔科夫链的统计语言模型，假设当前词的概率只与其前N-1个连续的词相关，即N-gram模型。使用该模型对$P(S)$重新表示如下：<br>$$<br>P(S)&#x3D;P(w_1,w_2,\dots,w_n)&#x3D;\prod P(w_i|w_{i-(N-1)},w_{i-(N-2)},\dots,w_{i-1})<br>$$<br>当N&#x3D;2时，称为二元语言模型，公式计算会变得简单很多，即只统计每个词之后最有可能生成什么词<br>$$<br>P(w_i|w_{i-1})&#x3D;\frac{count(w_i,w_{i-1})}{count(w_i)}<br>$$<br>这和马尔可夫链用于文本生成任务的过程非常类似。实际上，如果将词作为状态，词与词之间的转移概率作为马尔可夫链的转移概率，那么二者在生成任务上是本质相同的。关于马尔可夫链的更多知识，详见<a href="https://blog.bayh.top/2025/04/28/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/">这篇文章</a>。</p>
<h5 id="平滑技术"><a href="#平滑技术" class="headerlink" title="平滑技术"></a>平滑技术</h5><blockquote>
<p><strong>数据稀疏问题</strong>：统计语言模型中，训练数据中某些词或短语可能从未出现，或其上下文信息不足，导致模型在估计这些词序列概率时可能出现零概率问题。根据乘法原理，一个词的分布概率为0时，整个句子概率也为0。</p>
</blockquote>
<p>平滑技术就时为那些在训练数据中未出现或出现次数极少的单词或短语提供一个<strong>非零的概率估计</strong>，从而使模型预测更为合理。</p>
<p>加K平滑策略，加1平滑的泛化形式，相当于给每个统计单元与预设一个初始值K<br>$$<br>P(w_i|w_{i-1})&#x3D;\frac{count(w_i,w_{i-1})+K}{count(w_i)+K\times|V|}<br>$$</p>
<h6 id="古德-图灵平滑"><a href="#古德-图灵平滑" class="headerlink" title="古德-图灵平滑"></a>古德-图灵平滑</h6><p>将出现次数为r的事件的频率，用出现次数为r+1的事件的频率来估计，合理的调整低频事件概率分布<br>$$<br>\begin{aligned}<br>&amp;r^<em>&#x3D;\frac{(r+1)\cdot N_{r+1}}{N_r} \<br>&amp;P(w)&#x3D;\frac{r^</em>}{N}<br>\end{aligned}<br>$$</p>
<h6 id="回退平滑"><a href="#回退平滑" class="headerlink" title="回退平滑"></a>回退平滑</h6><p>当高阶N-gram数据不足时，回退到低阶来估计概率。下面为K回退的计算公式，结合回退机制和古德-图灵估计，对高低频采取不同的处理方式。<br>$$<br>P(w_n|w_{n-2},w_{n-1})&#x3D;\begin{cases}d_r\cdot\frac{C(w_{n-2},w_{n-1},w_n)}{C(w_{n-2},w_{n-1})},&amp;\mathrm{if~}C&gt;k\\alpha(w_{n-2},w_{n-1})\cdot P(w_n|w_{n-1}),&amp;\mathrm{otherwise}&amp;\end{cases}<br>$$<br>其中，$d_r$是折扣值，$\alpha$是回退权重</p>
<h3 id="神经网络语言模型"><a href="#神经网络语言模型" class="headerlink" title="神经网络语言模型"></a>神经网络语言模型</h3><p>虽然使用平滑技术能够使得统计语言模型正常工作，但仍存在一些问题</p>
<ul>
<li><p>只考虑短距离的上下文大幅度简化了计算，但也无法捕捉长距离的语义和语法依赖</p>
</li>
<li><p>随着词汇量和阶数的增加，模型参数规模呈指数级增长。一个词汇量为$V$的$n$元语言模型需要$V^n-1$个参数</p>
</li>
<li><p>基于词的表面共现统计，难以捕捉词与词之间的深层语义关系</p>
</li>
</ul>
<p>鉴于上面的问题，人们开始尝试使用神经网络建立语言模型，通过词向量的距离衡量单词之间的相似度，进而避免出现数据稀疏问题。根据神经网络的种类，又可以被分为前馈神经网络语言模型（FFNNLM）和循环神经网络语言模型（RNNLM）</p>
<h4 id="前馈神经网络语言模型"><a href="#前馈神经网络语言模型" class="headerlink" title="前馈神经网络语言模型"></a>前馈神经网络语言模型</h4><p><a target="_blank" rel="noopener" href="https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf">A Neural Probabilistic Language Model</a>该论文提出了一个非常经典的神经网络语言模型，模型的架构图如下</p>
<img src="https://files.catbox.moe/k489mq.png" alt="k489mq.png" style="zoom: 67%;" />



<h5 id="模型拆解"><a href="#模型拆解" class="headerlink" title="模型拆解"></a>模型拆解</h5><p>实际上，这个2003年提出的模型非常简单。和N-gram一样，NNLM也假设当前词仅依赖于前N-1个词。总体上看，将$w_i$前$n-1$个词的词向量进行拼接作为网络输入，经过一次非线性变换，最后输出字典中每个词的概率作为预测结果。<br>$$<br>\begin{aligned}<br>&amp;x&#x3D;(C(w_{t-1},C(W_{t-2}),\dots,C(W_{t-n+1})) \<br>&amp;y&#x3D;b+W\cdot x+U\cdot tanh(d+H\cdot x) \<br>&amp;p(w_i|w_{t-1},\ldots,w_{t-n+1})&#x3D;\frac{e^{y_{w_t}}}{\sum_ie^{y_i}}<br>\end{aligned}<br>$$</p>
<h6 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h6><p>模型训练时，需要最大化下列式子。第一部分是最大化给定序列$w_1^{t-1}$，下一个词为$w_t$的概率，第二部分$R(\theta)$为正则项。<br>$$<br>L&#x3D;\frac{1}{T}\sum_tlogf(w_t,w_{t-1},\ldots,w_{t-n+1};\theta)+R(\theta)<br>$$<br>参数优化方法使用梯度下降法。</p>
<h5 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h5><p>实验结果表明，这个结构在现在看来非常简单的NNLM模型比平滑处理的三元语言模型表现更好。模型虽然简单，但作为神经网络语言模型的开山之作，让人们意识到了神经网络语言模型的威力，逐渐进入了学界主流。</p>
<p>此外，该模型同时产生了副产品——词向量。</p>
<p>在表示输入层时，用到的映射函数$C(i)\in R^m$，其实就是词的分布式表示。$C$是一个$|V|\times m$的矩阵，$m$为词向量维度，矩阵的每一行就是一个单词的词向量。在模型训练过程中逐渐<strong>学习</strong>到词的分布式表示。可以说，后来的<strong>word2vec</strong>模型就是对FFNNML的<strong>简化和优化</strong>，且专注于词向量的训练。</p>
<h6 id="word2vec-Vs-FFNNLM"><a href="#word2vec-Vs-FFNNLM" class="headerlink" title="word2vec Vs FFNNLM"></a>word2vec Vs FFNNLM</h6><ul>
<li>FFNNLM是完整的语言模型，它的目标是最大化下一个词的预测概率，只是顺带学习了词向量。</li>
<li>是剥离出来的词向量学习模块，目标就是学习词向量，利用上下文预测中心词或者中心词预测上下文的形式，不建模完整的概率分布，通过大量的优化使得词向量训练变得高效、可扩展、泛用性强。</li>
</ul>
<p>word2vec的两个具体模型和优化方法详见<a href="https://blog.bayh.top/2025/04/27/%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/">文本数据处理方法</a>这篇文章。</p>
<h4 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h4><p>从方法创新的角度上看，从FFNNLM到RNNLM，只是网络结构上的过渡：用RNN&#x2F;LSTM替换了FFNN。所以，在这里有必要先介绍一下循环神经网络。</p>
<h5 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h5><p>在传统的前馈神经网路中，每个输入与输出之间的关系是独立的，即网络的输入和输出之间没有时间上的依赖关系。然而，在许多现实世界的任务中，数据往往是序列化的，即数据之间存在时间上的顺序关系。比如，NLP中的文本数据、语音识别中的音频数据、股票价格的时间序列数据等，都具有明显的时序性。</p>
<p>为了解决这一问题，循环神经网络RNN出场了。下图是RNN的循环示意图，同时接受当前时刻的输入和上一时刻隐藏状态，再由此计算出当前时刻的隐藏状态，供下一时刻使用 </p>
<p><img src="https://files.catbox.moe/k9ticb.png" alt="k9ticb.png"></p>
<p>采用$tanh$作为激活函数，其中$W_h$为层级之间的权重参数，$W_x$为当前输入的权重参数。<br>$$<br>h_t&#x3D;tanh(h_{t-1}W_h+x_tW_x+b)<br>$$</p>
<h6 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h6><p>出于减少训练时间或者简化模型的目的，层级之间的权重参数通常是相同的。在从后往前进行反向传播时，随着权重参数以指数形式进行积累，梯度传递到靠前的时间步时可能会变得非常小或者非常大，难以维持有效的学习过程。正是因为梯度消失的问题，RNN难以保持长期依赖性，因为在传播过程中，远期信息相关梯度会在传播过程中消失。</p>
<p>用数学语言描述，损失函数$L$对权重参数通过时间步进行反向传播<br>$$<br>\begin{aligned}<br>\frac{\partial L}{\partial W_h}&#x3D;\sum_{t&#x3D;1}^T\frac{\partial L}{\partial h_t}\cdot\frac{\partial h_t}{\partial W_h}\</p>
<p>\end{aligned}<br>$$<br>在RNN中，$\frac{\partial L}{\partial h_t}$ 依赖于所有未来时刻的隐藏状态，因此需要通过链式法则进行传播：<br>$$<br>\begin{aligned}<br>\frac{\partial L}{\partial h_t}&amp;&#x3D;\frac{\partial L}{\partial h_T}\cdot\prod_{k&#x3D;t}^{T-1}\frac{\partial h_{k+1}}{\partial h_k} \<br>&amp;&#x3D;\frac{\partial L}{\partial h_T}\cdot\prod_{k&#x3D;t}^{T-1}\left(\phi^{\prime}(a_k)\cdot W_h\right)<br>\end{aligned}<br>$$<br>其中 $a_k &#x3D; W_{h} h_{k} + \cdots$ 是激活函数的输入。</p>
<p>观察最右边的乘积项，由于这是矩阵和标量导数的乘积，如果：</p>
<ul>
<li>$|\phi’(a_k) \cdot W_{h}| &lt; 1$，则梯度会随着时间步数增长而指数级减小，导致<strong>梯度消失</strong>；</li>
<li>$|\phi’(a_k) \cdot W_{h}| &gt; 1$，则梯度会指数级增长，导致<strong>梯度爆炸</strong>。</li>
</ul>
<p>为了解决RNN由于梯度消失造成的难以捕捉长期依赖的问题，长短期记忆网络LSTM出现了。 </p>
<h5 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Z34y1k7mc?spm_id_from=333.788.videopod.sections&vd_source=3464224b3cb14e06ba5a481bb86a2285">视频讲解</a></p>
<p>全称为Long Short-Term Memory 长短期记忆网络，引入门控机制控制信息流动，更好的捕捉长期依赖关系。</p>
<p>为了方便理解，我们可以将传统 RNN 中的隐藏状态序列看作一条<strong>短期记忆链</strong>，它在时间上传递并更新当前的上下文信息。而 LSTM 在此基础上引入了另一条名为“细胞状态”的信息链条，可类比为<strong>长期记忆链</strong>。</p>
<p>在每个时间步，LSTM 通过门控机制（包括输入门、遗忘门和输出门）对长期记忆链上的信息进行选择性更新，从而实现对长期依赖信息的保留与调整。这两条信息链（隐藏状态与细胞状态）在每个时间步协同作用，实现了对短期与长期信息的有效建模。</p>
<p><img src="https://files.catbox.moe/je0gpg.png" alt="je0gpg.png"></p>
<p>其中$W_{f,i,o,c}$和$U_{f,i,o,c}$均为权重矩阵，三个门都只依赖当前输入和上一时刻隐藏状态，遗忘门和输入门来更新记忆单元，输出门控制信息从记忆单元流向隐藏状态。<br>$$<br>\begin{aligned}<br>&amp;f_{t}&#x3D;\sigma(W_fx_t+U_fh_{t-1}+b_f)&amp;&amp;\text{遗忘门}\<br>&amp;i_{t}&#x3D;\sigma(W_ix_t+U_ih_{t-1}+b_i)&amp;&amp;\text{输入门}\<br>&amp;o_{t}&#x3D;\sigma(W_ox_t+U_oh_{t-1}+b_o)&amp;&amp;\text{输出门}\<br>&amp;\tilde{c}<em>{t}&#x3D;\tanh(W_cx_t+U_ch</em>{t-1}+b_c)&amp;&amp;\text{候选伏态}\<br>&amp;c_{t}&#x3D;f_t\odot c_{t-1}+i_t\odot\bar{c}<em>t&amp;&amp;\text{记忆单元更新}\<br>&amp;h</em>{t}&#x3D;o_t\odot\tanh(c_t)&amp;&amp;\text{隐藏状态}<br>\end{aligned}<br>$$</p>
<h6 id="如何缓解梯度问题"><a href="#如何缓解梯度问题" class="headerlink" title="如何缓解梯度问题"></a>如何缓解梯度问题</h6><p>观察记忆状态更新公式：<br>$$<br>c_{t}&#x3D;f_t\odot c_{t-1}+i_t\odot\bar{c}<em>t<br>$$<br>在进行反向传播时：<br>$$<br>\begin{aligned}<br>&amp;\frac{\partial C_k}{\partial C</em>{k-1}}&#x3D;f_k+other\<br>&amp;\prod_{k&#x3D;t+1}^T\frac{\partial C_k}{\partial C_{k-1}}&#x3D;f_kf_{k+1}\ldots f_T+other\end{aligned}<br>$$<br>虽然在形式上依然是一个连乘式，但这里的$f_k$是可训练学习的，不会像RNN一样，每一步始终小于1或者大于1。所以整体也就不会一直减小，远距离梯度不至于完全消失，解决了RNN中梯度消失的问题，更好的捕捉长期依赖。</p>
<h5 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h5><p>是对传统RNN的改进，旨在缓解长序列训练中常见的梯度消失问题，同时比LSTM结构更简单、计算成本更低。</p>
<p>在GRU中，没有像LSTM新增的长期记忆链，而是直接将细胞状态和隐藏状态合并。此外，将遗忘门和输入门合并为更新门，并且同时充当输入门的作用，同时新增一个”重置门”，控制当前输入与过去隐藏状态的输入融合程度。这种结构设计使GRU在保持信息处理能力的同时，简化了模型，提高计算效率。<br>$$<br>\begin{aligned}<br>&amp;z_t&#x3D;\sigma(W_zx_t+U_zh_{t-1})&amp;&amp;\text{更新门}\<br>&amp;r_t&#x3D;\sigma(W_tx_t+U_rh_{t-1})&amp;&amp;\text{重置门} \<br>&amp;\tilde{h}<em>t&#x3D;\tanh(W_hx_t+U_h(r_t\odot h</em>{t-1}))&amp;&amp;\text{候选隐藏状态}\<br>&amp;h_t&#x3D;(1-z_t)\odot h_{t-1}+z_t\odot\tilde{h}_t&amp;&amp;\text{最终隐藏状态}\<br>\end{aligned}<br>$$</p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>GRU 适用于各种需要处理序列数据或时间依赖的任务，尤其在<strong>数据量较小或对训练效率要求较高</strong>的场景中表现良好。</p>
<p>实际上，LSTM 复杂的原因，除了在结构上天然地克服了梯度消失的问题，更重要的是具有更多的参数来控制模型；通过四倍于RNN的参数量，可以更加精细地预测时间序列变量。 </p>
<h4 id="循环神经网络语言模型"><a href="#循环神经网络语言模型" class="headerlink" title="循环神经网络语言模型"></a>循环神经网络语言模型</h4><p>论文地址 <a target="_blank" rel="noopener" href="https://www.fit.vut.cz/research/group/speech/public/publi/2010/mikolov_interspeech2010_IS100722.pdf">Recurrent neural network based language model</a></p>
<h5 id="模型拆解-1"><a href="#模型拆解-1" class="headerlink" title="模型拆解"></a>模型拆解</h5><p>给定上下文$s(t-1)$和当前词$w(t)$的情况下，预测下一个词为词汇表中第$k$个词的概率$y_k(t)$:<br>$$<br>\begin{aligned}<br>&amp;y_k(t)&#x3D;g(\sum_js_j(t)v_{kj}) \<br>&amp;\sum_ky_k(t)&#x3D;1<br>\end{aligned}<br>$$<br>$s_j(t)$是隐藏层的输出，$v_{kj}$是隐藏层到输出层的权重矩阵元素，$g$为Softmax函数</p>
<h6 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a>损失函数</h6><p>RNNLM的目标是使预测的概率分布$y(t)$尽可能接近真实的目标词的分布。</p>
<p>交叉熵损失函数衡量预测分布和真实分布之间的差异。对于单个样本和整个训练数据集，损失函数定义为：<br>$$<br>\begin{aligned}<br>&amp;L(t)&#x3D;-\sum_k{d_k(t)log(y_k(t))} \<br>&amp;L&#x3D;-\frac{1}{T}\sum_{t&#x3D;1}^TL(t)<br>\end{aligned}<br>$$</p>
<h3 id="序列到序列模型"><a href="#序列到序列模型" class="headerlink" title="序列到序列模型"></a>序列到序列模型</h3><p>序列到序列模型（Seq2Seq）是神经网络语言模型的一种，广泛应用于机器翻译、文本摘要、对话生成等任务。它的核心思想是将一个输入序列编码成一个语义表示，然后再由解码器将这个表示转换为目标序列。这个过程体现了语言模型的本质：根据已有的信息预测合理的语言输出。</p>
<p>用数学语言描述，给定一个源语言序列$X$，训练模型预测目标序列$Y&#x3D;(y_1,y_2,\dots,y_T)$，让模型学习：<br>$$<br>P(Y\mid X)&#x3D;P(y_1\mid X)\cdot P(y_2\mid y_1,X)\cdots\cdots P(y_T\mid y_1,…,y_{T-1},X)<br>$$<br>在Seq2Seq模型中，我们可能会看到$ P(y_t\mid y_{&lt;t},X)$ 这样的表达式，其实就表示模型在看到输入$X$和目标前缀$y_{&lt;t}$后，预测下一个词$y_t$的概率分布，取其中$y_t$的概率。</p>
<h4 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h4><p>下图为编码器-解码器模型的结构，先对句子$X(x_1,x_2,x_3,x_4)$编码，然后再解码为输出$Y(y_1,y_2,y_3)$，就能实现机器翻译和对话生成等热任务。</p>
<p><img src="https://files.catbox.moe/gxyjt8.png" alt="gxyjt8.png"></p>
<p>Seq2Seq 最早是基于循环神经网络构建的，即编码器和解码器的核心结构都是RNN，后来演变出使用LSTM、GRU等改进结构来解决长距离依赖的问题。后来，为了提高效果，还加入了注意力机制，并最终发展成Transformer架构，基于注意力机制的序列到序列模型成为主流。</p>
<p>无论使用哪种结构，其本质都是利用神经网络对语言进行建模，因此属于神经网络语言模型的范畴。它相比传统的语言模型更强大，能够处理输入输出长度不等的复杂语言任务。</p>
<p>为了讲清楚Transformer这一架构，我们先从Attention机制开始说起。</p>
<h4 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xS4y1k7tn?spm_id_from=333.788.videopod.sections&vd_source=3464224b3cb14e06ba5a481bb86a2285">注意力机制-视频讲解</a></p>
<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>观察上图中Encoder-Decoder结构，可以发现如下问题：</p>
<ul>
<li>编码器将整个输入序列压缩为一个固定长度的上下文向量，可能导致信息丢失，尤其是在处理长序列时。</li>
<li>解码器只能依靠单一的上下文向量来生成整个输出序列，缺乏对输入序列中具体位置的关注能力。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/Neural-Machine-Translation-by-Jointly-Learning-to-Bahdanau-Cho/fa72afa9b2cbc8f0d7b05d52548906610ffbb9c5">Neural Machine Translation by Jointly Learning to Align and Translate</a> Attention机制的开山之作，首次引入Attention机制，旨在解决传统编码器-解码器（Encoder-Decoder）模型在处理长句子时的性能下降问题。作者提出了一种新的神经机器翻译模型，该模型在解码每个词时，通过注意力机制自动对源句子的不同部分进行加权，从而实现对源句子的动态对齐和翻译。这种机制允许模型在生成每个目标词时，关注源句子中最相关的部分，从而提高翻译质量。</p>
<p><img src="https://files.catbox.moe/jx85vk.png" alt="jx85vk.png"></p>
<h5 id="Additive-Attention"><a href="#Additive-Attention" class="headerlink" title="Additive Attention"></a>Additive Attention</h5><p>加性注意力机制</p>
<ol>
<li><p>输入经过双向RNN编码，得到隐藏状态序列$h&#x3D;{h_1,h_2,\dots,h_T}$</p>
</li>
<li><p>对每个目标词计算源词的对齐程度，并归一化注意力分数<br> $$<br> \begin{aligned}<br> &amp;e_{ti}&#x3D;v_a^T\tanh(W_as_{t-1}+U_ah_i)\<br> &amp;a_{ti}&#x3D;\frac{exp(e_{ti})}{\sum_{k&#x3D;1}^Texp(e_{tk})}<br> \end{aligned}<br> $$</p>
<p> $s_{t-1}$为前一个时间步的解码器状态，其余为可学习的参数矩阵</p>
</li>
<li><p>计算上下文向量并生成目标词<br>$$<br>\begin{aligned}<br> &amp;c_t&#x3D;\sum_{i&#x3D;1}^Ta_{ti}h_i\<br> &amp;s_t&#x3D;f(s_{t-1},y_{t-1},c_t)\<br> &amp;P(y_t|y_{&lt;t},x)&#x3D;g(s_t,c_t)<br> \end{aligned}<br>$$</p>
</li>
</ol>
<p>模型不再压缩为一个固定向量，而是为每个目标词选择性地关注源句的不同部分。</p>
<h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>尽管引入Attention机制显著提升了模型性能，但当时的架构仍依赖于复杂的递归神经网络。由于RNN在计算上存在时间步之间的依赖，导致模型难以实现并行计算，限制了训练效率。为了解决这一问题，研究者们提出了一种完全基于注意力机制的全新架构 —— Transformer，彻底摒弃了RNN结构，从而显著提升了并行处理能力与训练效率。</p>
<p><a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">Attention Is All You Need</a> Transformer的开山之作，在语言模型的发展史上具有划时代的意义。</p>
<p>在介绍transformer结构之前，我们先讲清楚几个关键技术。</p>
<h4 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h4><p>由于出于对并行计算效率的考虑，Transformer 模型完全摒弃了传统的循环神经网络（RNN）结构。然而，RNN 通过其递归结构天然地捕获了序列中各个词语的顺序信息，而这类顺序信息在自然语言理解中是至关重要的。如果完全忽略词语的位置信息，模型将无法区分语序不同但词汇相同的句子，从而导致语义理解偏差。</p>
<p>为了解决这一问题，引入了位置编码（Postion Encoding)机制，用以显式地为模型提供每个词在序列中的相对或绝对位置信息。这些位置信息被表示为向量，并与词嵌入（Word Embedding）具有相同的维度，从而可以通过简单的向量加法将两者融合。</p>
<blockquote>
<p>思考：为什么可以直接简单相加？</p>
<p>词向量和位置向量记录的是两类本质上完全不同的信息：前者捕捉的是词语的语义信息，而后者则编码词语在序列中的位置信息。尽管我们将它们简单相加作为模型输入，但这一操作背后的合理性目前并没有严格的数学理论支撑。我们只是<strong>经验性地认为</strong>，在后续深层神经网络的训练过程中，模型可以“自动”从这些融合后的数值中<strong>学习出隐含的结构和规律</strong>，进而完成有效的语言理解。</p>
<p>这种“结果导向”的思维方式，正体现了近年来人工智能领域的一个重要趋势转变。实际上，从2012年AlexNet以压倒性优势赢得竞赛以来，深度学习模型的设计就逐渐从追求可解释性转向<strong>追求性能优先</strong>。在这一背景下，<strong>模型效果被置于首位</strong>，而对模型内部工作机制的可解释性探索则相对被弱化甚至忽略。</p>
</blockquote>
<h5 id="位置编码的计算"><a href="#位置编码的计算" class="headerlink" title="位置编码的计算"></a>位置编码的计算</h5><p>Transformer中的位置编码使用$sin$和$cos$交替的形式：<br>$$<br>\begin{aligned}<br>&amp;PE_{(pos,2i)}&#x3D;sin(\frac{pos}{10000^{2i&#x2F;d_{model}}}) \<br>&amp;PE_{(pos,2i+1)}&#x3D;cos(\frac{pos}{10000^{2i&#x2F;d_{model}}})<br>\end{aligned}<br>$$<br>$d_{model}$即为当前模型位置向量的维度</p>
<h5 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h5><p>观察上述的计算公式，位置编码本身是一个绝对位置信息，但在语言模型中，相对位置也很重要。<br>$$<br>\left.<br>\left{\begin{array}{l}sin(\alpha+\beta)&#x3D;sin\alpha cos\beta+cos\alpha sin\beta \<br>cos(\alpha+\beta)&#x3D;cos\alpha cos\beta-sin\alpha sin\beta\end{array}\right.<br>\right.<br>$$<br>根据上述的公式，当我们需要计算$pos+k$位置上的位置编码时，可以通过位置$pos$和$k$的编码表示：<br>$$<br>\left.<br>\left{\begin{array}{l}PE(pos+k,2i)&#x3D;PE(pos,2i)\times PE(k,2i+1)+PE(pos,2i+1)\times PE(k,2i)\<br>PE(pos+k,2i+1)&#x3D;PE(pos,2i+1)\times PE(k,2i+1)-PE(pos,2i)\times PE(k,2i)\end{array}\right.<br>\right.<br>$$<br>这意味着，<strong>两个位置编码之间的差异只与它们之间的距离有关，而与它们的具体位置无关</strong>。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Transformer 使用 sin 和 cos 交替编码，是一种<strong>无需训练却具有丰富结构的表示方式</strong>，它既能保留词的<strong>绝对位置信息</strong>，又能通过数学结构间接捕捉<strong>相对位置关系</strong>，从而弥补模型自身结构中缺乏顺序感的缺陷。</p>
<h4 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h4><p>在上文的Attention部分，我们简单介绍了加性注意力进制的基本原理，$a_{ti}$表示当前位置$t$对于输入序列中地$i$位置的关注权重。而在Self-Attention机制中，模型会对输入序列中每个位置计算其对其他所有位置的注意力权重，从而实现信息的全局建模。</p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol>
<li><p>对于输入序列$S(w_1,w_2,\dots,w_n)$，首先构造$n\times d$的输入矩阵$X$，$X(i)&#x3D;WE(w_i)+PE(i)$</p>
</li>
<li><p>通过三个随机初始化的大小为$d\times d$的矩阵$W^Q,W^K,W^V$<br> $$<br> \begin{aligned}<br> &amp;Q&#x3D;XW^Q\<br> &amp;K&#x3D;XW^K\<br> &amp;V&#x3D;XW^V<br> \end{aligned}<br> $$<br> Q,K,V的形状为$n\times d$</p>
</li>
<li><p>使用点积相似度计算注意力分数<br> $$<br> Attention &#x3D; softmax(\frac{QK^T}{\sqrt{d_k}})V<br> $$</p>
</li>
</ol>
<h5 id="各矩阵的含义"><a href="#各矩阵的含义" class="headerlink" title="各矩阵的含义"></a>各矩阵的含义</h5><ul>
<li>Q 代表着需要编码的词的信息</li>
<li>K 代表着句子中其它词的信息，相乘后得到句子中其它词的权重值； </li>
<li>V 代表着每个位置单词蕴含的语义信息，在被加权求和后作为待编码词的编码。</li>
</ul>
<p>$QK^T$的形状为$n\times n$，就是一个word2word的attention map，每个词对应每个词都会有一个权重。</p>
<p>再与$V$相乘，根据矩阵的乘法规则。结果中的矩阵元素$A_{ij}$就代表单词$i$在对这个句子总所有词的关注度在语境$j$下的总和。<br>$$<br>A_{ij}&#x3D;\sum_l^d(QK^T)<em>{il}V</em>{lj}<br>$$</p>
<h4 id="Multi-head-Attention"><a href="#Multi-head-Attention" class="headerlink" title="Multi-head Attention"></a>Multi-head Attention</h4><h5 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h5><p>Mutil-head Attention就是Self-Attention的进阶版，并不是直接利用$d$维的Q,K,V矩阵计算，而是将其都划分为多头，并分别计算注意力，最后通过全连接层获得新的注意力值。</p>
<p>设有$h$个头，每个头的维度即为$d_h&#x3D;d&#x2F;h$，<br>$$<br>\begin{aligned}<br>&amp;Q_i&#x3D;XW_i^Q,\quad K_i&#x3D;XW_i^K,\quad V_i&#x3D;XW_i^V \<br>&amp;\text{head}_i&#x3D;\text{Attention}(Q_i,K_i,V_i)\<br>&amp;\text{MultiHead}(X)&#x3D;\text{Concat}(\text{head}_1,\text{head}_2,\dots,\text{head}_h)W^O<br>\end{aligned}<br>$$<br>Self-Attention的计算公式中的 ${d_k}$ 其实就表示的是每个头的维度，防止梯度过大导致训练不稳定。</p>
<p>至此，Transformer架构中注意力部分的计算的整个流程如下图所示。</p>
<p><img src="https://files.catbox.moe/2lvtbi.png" alt="2lvtbi.png"></p>
<h5 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h5><p>多个头用不同的参数训练，让模型在不同的注意力视角下捕捉不同的注意力的语义信息，增强最终表示的丰富性。</p>
<h4 id="Masked"><a href="#Masked" class="headerlink" title="Masked"></a>Masked</h4><p>在上文中提到，$QK^T$得到的是一个attention map，而掩码机制就是掩盖住矩阵的上三角区域，只保留下三角区域，具体做法就是在上三角区域加上一个很大的负数，使得经过Softmax后接近于0，相当于屏蔽</p>
<h5 id="意义-2"><a href="#意义-2" class="headerlink" title="意义"></a>意义</h5><p>防止模型看到未来信息。在序列生成任务时，不应该看到后面的词，否则模型在训练阶段可以利用未来消息进行预测。然而在测试阶段中，后面的词是不会对当前翻译结果产生贡献的。所以为了让训练和测试阶段的行为一致，避免过拟合</p>
<h4 id="Add-Norm"><a href="#Add-Norm" class="headerlink" title="Add &amp; Norm"></a>Add &amp; Norm</h4><p>从上图中的结构可以发现，<strong>Add &amp; Norm</strong>是在每个子层（自注意力子层，前馈子层）之后的一个标准步骤</p>
<p>假设一个子层的输入为$x$，输出是$SubLayer(x)$，那么输出<br>$$<br>\text{Output}&#x3D;\text{LayerNorm}(x+\text{SubLayer(x)})<br>$$<br>实际上包括了残差连接和层归一化两个步骤：<br>$$<br>\begin{aligned}<br>&amp;z&#x3D;x+\text{SubLayer}(x)&amp;&amp;\text{残差连接}\<br>&amp;\text{LayerNorm}(z)&#x3D;\frac{z-\mu}\sigma\cdot\gamma+\beta &amp;&amp;\text{层归一化}<br>\end{aligned}<br>$$<br>其中$\mu,\sigma$是均值和标准差，$\gamma,\beta$是可训练参数</p>
<h5 id="意义-3"><a href="#意义-3" class="headerlink" title="意义"></a>意义</h5><ul>
<li><p>残差连接：帮助训练更深的网络，避免梯度消失；保留原始输入的信息。</p>
<p>最终输出是“原始输入+学习到的偏差”</p>
<p>通过加上原始输出，在反向传播的梯度计算时候留一个恒等项$I$，即使$\frac{\partial\mathcal{F}(x)}{\partial x}$很小，仍能保证梯度不完全为0。<br>$$<br>\begin{aligned}<br>&amp;\mathrm{Output}&#x3D;x+\mathcal{F}(x)\<br>&amp;\frac{\partial\text{Output}}{\partial x}&#x3D;\frac{\partial(x+\mathcal{F}(x))}{\partial x}&#x3D;I+\frac{\partial\mathcal{F}(x)}{\partial x}<br>\end{aligned}<br>$$</p>
</li>
<li><p>层归一化：稳定训练，提高收敛速度；避免不同特征维度的分布不一致。</p>
</li>
</ul>
<h4 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h4><p>有了上面知识的铺垫，我们再来看论文中Transformer整体框架图。</p>
<img src="https://files.catbox.moe/fwu6us.png" alt="fwu6us.png" style="zoom: 50%;" />

<p>实际上，在序列到序列模型部分，我们提到Transformer模型也是Seq2Seq模型，从输入输出角度来讲，就是通过Encoder将输入读进去，然后用Decoder得到输出。所以模型可以简化表示成如下形式：</p>
<p><img src="https://files.catbox.moe/c9mjn7.png" alt="c9mjn7.png"></p>
<p>编码部分有若干个Encoder组成，每个Encoder主要由多头注意力进制和前馈神经网络组成；解码部分也由若干Decoder组成，每个Decoder组成和Encoder类似，但多了一层Encoder-Decoder Attention，该层会利用编码部分的输出。接下来，我们继续拆解编码器结构，得到如下图所示的结构，下面依次对Encoder、Decoder、模型输出展开介绍，并模拟整个模型从输入到输出的数据流动</p>
<p><img src="https://files.catbox.moe/mj1r6q.png" alt="mj1r6q.png"></p>
<h5 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h5><ol>
<li>词向量加上位置向量作为编码器的输入$x$</li>
<li>经过多头自注意力进制计算后，得到注意力分数$z$</li>
<li>进行残差连接$x+z$和层归一化，得到输出$x’$</li>
<li>经过前馈神经网络层，包括两个线性变换和一个Relu激活函数，$FFN(x)&#x3D;max(0,xW_1+b_1)W_2+b2$</li>
<li>再经过Add &amp; Norm得到输出并作为下一个编码器的输入</li>
</ol>
<h5 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h5><p>和Encoder过程非常相似，值得注意的是Encoder-Decoder Attention。</p>
<p>并不是一种新的注意力进制，指的是利用Decoder提供的$Q_d$矩阵，和Encoder提供的$K_e,V_e$矩阵来计算注意力分数。和加性注意力进制一个道理，我们关注的还是<strong>输出位置对每个输入位置的注意力</strong>。</p>
<h5 id="模型输出"><a href="#模型输出" class="headerlink" title="模型输出"></a>模型输出</h5><p>解码器的输出是一个向量，经过liner+Softmax变为单词</p>
<p>liner：简单的全连接网络，把解码器输出投影为一个$|V|$维向量</p>
<p>softmax：进一步归一化，将分数转化为概率，再根据概率最大的索引查找关联词</p>
<h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><p>模型输出的是对每个token的预测向量，对于语言建模任务依然使用交叉熵误差：<br>$$<br>\mathcal{L}&#x3D;-\sum_t\log P(y_t\mid y_{&lt;t},X)<br>$$<br>使用梯度下降法进行参数优化。</p>
<h3 id="基于Trm的预训练语言模型"><a href="#基于Trm的预训练语言模型" class="headerlink" title="基于Trm的预训练语言模型"></a>基于Trm的预训练语言模型</h3><h4 id="预训练语言模型"><a href="#预训练语言模型" class="headerlink" title="预训练语言模型"></a>预训练语言模型</h4><h5 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h5><p>在深度学习与自然语言处理的交汇点上，”预训练”这一概念彻底改变了我们构建语言模型的方式。预训练本质上是一种知识迁移的范式，其核心思想是让模型在海量未标注文本中自主学习语言的通用规律，而非直接针对特定任务进行训练。具体来说，先在大规模数据集上训练模型，让它学习通用的特征和知识，再将其应用到具体任务中进行进一步训练。这种先验知识的积累使模型摆脱了传统监督学习对标注数据的依赖，为后续任务适配提供了可迁移的知识基础。</p>
<h5 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h5><p>预训练模型是预训练这一过程的具象化产物。更具体的说，是经过预训练阶段训练完成、已经掌握了通用语言能力的模型，从而可以用于下游任务。</p>
<p>在<a href="https://blog.bayh.top/2025/04/27/%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/">文本数据处理方法</a>一文中我提到的<strong>词向量迁移学习</strong>，本质上也是一种预训练的雏形。因为训练好的词向量是捕获了词的语义和语法关系，这些知识是通用的，可用于文本分类、机器翻译等多种下游任务，无需重新训练。所以，word2vec、Glove可以看作是<strong>预训练词向量模型</strong>，通过浅层网络学习静态词嵌入，为后续任务提供基础语义单元。</p>
<p>预训练语言模型以<strong>自然语言文本数据</strong>为训练对象，是预训练技术在自然语言处理领域的具体实现。</p>
<h5 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h5><p>预训练模型下游使用的方法可以分为几种主要策略</p>
<ol>
<li><p>预训练+微调（Fine-tuning)</p>
<p> 最主流的方法，在具体下游任务的数据上进一步微调整个模型或部分参数，能最大限度地适应下游任务。</p>
</li>
<li><p>预训练+冻结（Feature Extraction）</p>
<p> 模型预训练后参数不变，只把它当作一个“特征提取器”，在上层加一个简单分类器或回归头。特别适合数据量较小或算力有限的情况</p>
</li>
<li><p>参数高效微调（LoRA、Adapter)</p>
<p> 不微调整个模型，而是在模型中插入一些轻量模块，只训练这些模块带来的少量新增参数</p>
</li>
<li><p>零样本&#x2F;少样本学习（Zero-shot&#x2F;Few-shot)</p>
<p> 直接利用模型的泛化能力，无需额外微调。通过设计提示词（Prompt）进行任务引导，模型不更新参数</p>
</li>
</ol>
<h4 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h4><p>全称Embeddings from Language Models，在论文<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1802.05365">Deep contextualized word representations</a>中首次提出，该论文也是NAACL在2018年度的最佳论文。</p>
<p>ELMO是一种经典的预训练语言模型，具体地说，是一种基于双向LSTM的语言模型。标志着自然语言处理领域从静态词嵌入向上下文相关词表示的重要转折点。与传统的词向量不同，ELMO能根据上下文动态地为同一个词生成不同的向量表示。</p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p><img src="https://files.catbox.moe/y0l7tk.png" alt="y0l7tk.png"></p>
<p>核心思想是利用一个双向语言模型BiLM，分别从前向和后向理解文本内容，从而生成上下文相关词向量。</p>
<p>在传统的前向语言模型中，模型通过给定前文来预测当前词：<br>$$<br>p(w_1,w_2,\dots,w_n)&#x3D;\prod_{k&#x3D;1}^Np(w_k|w_1,w_2,\dots,w_{k-1})<br>$$<br>在后向语言模型中，通过后给定后文来预测当前词：<br>$$<br>p(w_1,w_2,w_n)&#x3D;	\prod_{k&#x3D;1}^NP(w_k|w_{k+1},w_{k+2},w_n)<br>$$<br>ELMO就是将二者结合起来，同时追求二者的概率最大化，体现为最大化对数前向和后向的似然概率：<br>$$<br>\begin{aligned}<br>&amp;\sum_{k&#x3D;1}^{N}(:\log p(t_{k}\mid t_{1},\ldots,t_{k-1};\Theta_{x},\overrightarrow{\Theta}<em>{LSTM},\Theta</em>{s})\<br>&amp;+\log p(t_{k}\mid t_{k+1},\ldots,t_{N};\Theta_{x},\overleftarrow{\Theta}<em>{LSTM},\Theta</em>{s}):):<br>\end{aligned}<br>$$</p>
<h5 id="词向量生成"><a href="#词向量生成" class="headerlink" title="词向量生成"></a>词向量生成</h5><p>对于L层的双向语言模型，每个单词一共有$2*L+1$个表征<br>$$<br>\begin{aligned}<br>R_{k}&amp;&#x3D;\quad{\mathbf{x}<em>{k}^{LM},\overrightarrow{\mathbf{h}}</em>{k,j}^{LM},\overleftarrow{\mathbf{h}}<em>{k,j}^{LM}\mid j&#x3D;1,\ldots,L} \<br>&amp;&#x3D;\quad{\mathbf{h}</em>{k,j}^{LM}\mid j&#x3D;0,\ldots,L}<br>\end{aligned}<br>$$<br>其中，$h_{k,0}^{LM}$为模型输入，对于其它层，$h_{k,j}^{LM}&#x3D;[\overrightarrow{h_{k,j}^{LM}};\overleftrightarrow{h_{k,j}^{LM}}]$</p>
<p>面对这么多向量，最简单的方法是直接利用顶层$h_{k,L}^{LM}$。更一般地说，针对特定任务计算所有BiLM层的权重：<br>$$<br>\mathbf{ELMo}<em>k^{task}&#x3D;E(R_k;\Theta^{task})&#x3D;\gamma^{task}\sum</em>{j&#x3D;0}^{L}s_{j}^{task}\mathbf{h}_{k,j}^{LM}.<br>$$<br>每层LSTM学到的东西都不一样，针对每个任务每层的重要性也不一样，这就是$\gamma^{task}$和$s_j^{task}$参数的含义</p>
<h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><p>首次证明上下文相关词嵌入能显著提升下游任务性能。预训练的ELMo模型可直接作为特征提取器，无需从头训练。但是依然一些局限性：</p>
<ul>
<li>基于LSTM，无法实现并行计算。</li>
<li>无法同时利用上下文，只是将输入分别送给两个模型并最大化总和概率。</li>
<li>依赖任务特定模式，需为每个任务单独设计模型，在词向量生成公式也可以看出，各任务的权重参数不同。</li>
</ul>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><p>Transformer架构的引入为预训练语言模型提供了新路径。其自注意力机制打破了循环神经网络对序列的依赖，能够并行处理输入序列并动态建模长程依赖关系，大幅提升了模型的表达能力和训练效率。在此基础上，也衍生出了BERT和GPT两种典型模型，分别代表了两种不同的预训练范式。在本篇中主要介绍在自然处理任务上使用较为广泛的BETR模型，其余模型待续…</p>
<h3 id="BERT-模型"><a href="#BERT-模型" class="headerlink" title="BERT 模型"></a>BERT 模型</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>全称Bidirectional Encoder Representations from Transformers，在论文<a target="_blank" rel="noopener" href="http://arxiv.org/abs/1810.04805">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a>中首次提出。</p>
<p>可以作为自然语言处理领域里程碑式的工作，同时还是近年来优秀预训练语言模型的集大成者。BERT的意义在于，从大量无标记数据集中训练得到的深度模型，可以<strong>显著</strong>提高<strong>各项</strong>自然语言处理任务的准确率。</p>
<ol>
<li>借鉴ELMO模型的双向编码</li>
<li>借鉴GPT用trm作为特征提取器的思路</li>
<li>借鉴word2vec中CBOW方法</li>
</ol>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>简单的说，模型的结构就是双向连接的多个Encoder组成。从形式上看，BERT之于Transformer就像Word2Vec之于FFNNLM，都是改变了后者的训练目标，剥离出了一部分得到一个专门的预训练模型。</p>
<p><img src="https://files.catbox.moe/1vha7t.png" alt="1vha7t.png"></p>
<h4 id="模型训练-1"><a href="#模型训练-1" class="headerlink" title="模型训练"></a>模型训练</h4><p>BERT的训练过程是主要分为两个阶段：预训练和微调。预训练是BERT的核心阶段，基于Trm的Encoder结构，采用<strong>自监督学习</strong>的方式，用语言掩码模型（MLM）方法训练词的语义理解能力；用下句预测（NSP）方法训练句子之间的理解能力，从而更好地支持下游任务。除了输出层之后，微调和预训练使用相同的架构，相同的预训练模型参数用于初始化不同下游任务的模型。在微调过程中，所有参数都会进行微调。</p>
<p><img src="https://files.catbox.moe/lbl7qi.png" alt="lbl7qi.png"></p>
<h4 id="语言掩码模型"><a href="#语言掩码模型" class="headerlink" title="语言掩码模型"></a>语言掩码模型</h4><p>借鉴完形填空任务和CBOW的思想，使用MLM方法训练模型。MLM方法简单来说就是随机去掉句子中的部分单词，再让模型来预测被去掉的单词。其中，被去掉的词称为掩码词。在CBOW中，每个词都会作为被预测的中心词，在MLM中则是随机选择15%的词进行掩码。</p>
<p>考虑到在模型微调训练阶段或模型推理阶段，输入的文本中将没有[MASK]，进而导致产生由训练和预测数据偏差导致的性能损失的的问题，BERT并没有将所有的掩码词替换为[MASK]，而是按照一定比例进行三类替换选项：</p>
<ul>
<li>80% 替换为[MASK]</li>
<li>10% 替换为随机词</li>
<li>10% 保持不变</li>
</ul>
<p>编码器不知道那些词是需要被预测的，哪些词是错误的，被迫需要学习每个token的表示向量。这样也得以让模型通过双向上下文学习词的深层语义表示，捕捉词与词之间的复杂关系。</p>
<h4 id="下一句预测"><a href="#下一句预测" class="headerlink" title="下一句预测"></a>下一句预测</h4><p>在很多自然语言处理的下游任务中，如问答和自然语言推断，都基于两个句子做逻辑推理，而语言模型并不具备直接捕获句子之间的语义联系的能力，为了<strong>学会捕捉句子之间的语义联系</strong>，BERT 采用了下句预测作为无监督预训练的一部分。</p>
<p>NSP的训练任务可以描述为，给定两个子句A,B，模型需要判断B是否是A的子句。具体做法是，输入的句子将由两个语句组成，其中，50% 的概率将语义连贯的两个连续句子作为训练文本；另外 50% 的概率将完全随机抽取两个句子作为训练文本。</p>
<p>输入格式为<code>[CLS]&lt;句子A&gt;[SEP]&lt;句子B&gt;[SEP]</code>，通过训练[CLS]编码后的输出标签，BERT 可以学会捕捉两个输入句对的文本语义。</p>
<h4 id="输入表示"><a href="#输入表示" class="headerlink" title="输入表示"></a>输入表示</h4><p>为了使BERT能够处理各种下游任务，我们的输入表示法能够在一个标记序列中明确表示一个句子和一对句子。在论文中，句子可以是任意跨度的连续文本，而不是实际的语言句子。序列指的是BERT的输入标记序列，可以是一个句子，也可以是两个句子。</p>
<p>首先将每个词转化为WordPiece分词，并且第一个标记总是特殊分类标记[CLS]，然后再如下图所示从上到下依次添加词嵌入、片段分割嵌入和位置嵌入。</p>
<ul>
<li>Token embed：词嵌入，onre-hot词表映射编码</li>
<li>Segement embed：分割嵌入，当输入为句子对时，将前一个句子赋值为0，后一个句子赋值为1；只有一个句子则全是0。</li>
<li>Position embed：位置嵌入，不同与Trm用三角函数表示，是在与预训练过程中训练得到。</li>
</ul>
<p><img src="https://files.catbox.moe/e7kvfu.png" alt="e7kvfu.png"></p>
<h4 id="微调-下游任务改造"><a href="#微调-下游任务改造" class="headerlink" title="微调-下游任务改造"></a>微调-下游任务改造</h4><p><img src="https://files.catbox.moe/guszfr.png" alt="guszfr.png"></p>
<h5 id="句对分类"><a href="#句对分类" class="headerlink" title="句对分类"></a>句对分类</h5><p>给定两个句子，判断它们的关系，称为句对分类，例如判断句对是否相似、判断后者是否为前者的答案。</p>
<p>如上图a所示，句对用[SEP]分隔符拼接成文本序列，在句首加入标签[CLS]，将句首标签所对应的输出值作为分类标签，计算预测分类标签与真实分类标签的交叉熵，将其作为优化目标，在任务数据上进行微调训练。</p>
<ul>
<li><p>二分类任务：不需要对输入输出作任何改动，直接利用NSP的训练方法即可。</p>
</li>
<li><p>多分类任务：在[CLS]的输出特征向量的后面接上liner+Softmax，保证输出维数和类别数目一致，最后通过argmax操作得到类别结果。</p>
</li>
</ul>
<h5 id="单句分类"><a href="#单句分类" class="headerlink" title="单句分类"></a>单句分类</h5><p>给定一个句子，判断该句子的类别，统称为单句分类，例如判断情感类别、判断是否为语义连贯的句子。</p>
<p>如上图b所示，单句分类在句首加入标签[CLS]，将句首标签所对应的输出值作为分类标签，计算预测分类标签与真实分类标签的交叉熵，将其作为优化目标，在任务数据上进行微调训练。</p>
<p>实际上，只有输入与句对分类拜托你，这里不再赘述。</p>
<h5 id="文本问答"><a href="#文本问答" class="headerlink" title="文本问答"></a>文本问答</h5><p>给定一个问句和蕴含答案的句子，找出答案在后句中的位置，称为文本问答。</p>
<p>为了标注答案的起始位置和终止位置，引入两个辅助变量$s$和$e$。如上图c所示，将句子B中每一个token得到的特征向量$T_i’$经过全连接层后，分别于向量$s,e$求内积，对所有内积进行Softmax操作，即可得到每个输入词Tok m作为答案起始位置和终止位置的概率，取概率最大的片段即可。</p>
<p>文本回答任务的微调训练使用了两个技巧：</p>
<ol>
<li>用全连接层把 BERT 提取后的深层特征向量转化为用于判断答案位置的特征向量</li>
<li>引入辅助向量 s 和 e 作为答案其实位置和终止位置的基准向量，明确优化目标的方向和度量方法</li>
</ol>
<h5 id="单句标注"><a href="#单句标注" class="headerlink" title="单句标注"></a>单句标注</h5><p>给定一个句子，标注每个次的标签，称为单句标注。</p>
<p>单句标注任务和 BERT 预训练任务具有较大差异，但与文本问答任务较为相似。如上图d所示，同时是在每个输入词得到的最终语义向量之后添加全连接层，将语义特征转化为序列标注任务所需的特征，单句标注任务需要对每个词都做标注，因此不需要引入辅助向量，直接对经过全连接层后的结果做Softmax操作，即可得到各类标签的概率分布。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.bayh.top">15H</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.bayh.top/2025/05/04/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E7%BB%BC%E8%BF%B0/">https://blog.bayh.top/2025/05/04/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E7%BB%BC%E8%BF%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.bayh.top" target="_blank">15H</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SLM/">SLM</a><a class="post-meta__tags" href="/tags/NNLM/">NNLM</a><a class="post-meta__tags" href="/tags/N-gram/">N-gram</a><a class="post-meta__tags" href="/tags/Transformer/">Transformer</a><a class="post-meta__tags" href="/tags/PLM/">PLM</a><a class="post-meta__tags" href="/tags/ELMo/">ELMo</a><a class="post-meta__tags" href="/tags/BERT/">BERT</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/05/02/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94SMOTE%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6/" title="不平衡数据——SMOTE及其改进算法的比较研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">不平衡数据——SMOTE及其改进算法的比较研究</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">15H</div><div class="author-info-description">悟已往之不谏，知来者之可追</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ba-YH"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">语言模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">统计语言模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#N-gram"><span class="toc-number">2.1.</span> <span class="toc-text">N-gram</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E6%BB%91%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.1.</span> <span class="toc-text">平滑技术</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%A4%E5%BE%B7-%E5%9B%BE%E7%81%B5%E5%B9%B3%E6%BB%91"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">古德-图灵平滑</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E5%B9%B3%E6%BB%91"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">回退平滑</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">神经网络语言模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">前馈神经网络语言模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%8B%86%E8%A7%A3"><span class="toc-number">3.1.1.</span> <span class="toc-text">模型拆解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">损失函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">意义</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#word2vec-Vs-FFNNLM"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">word2vec Vs FFNNLM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">3.2.</span> <span class="toc-text">循环神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RNN"><span class="toc-number">3.2.1.</span> <span class="toc-text">RNN</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">梯度消失</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LSTM"><span class="toc-number">3.2.2.</span> <span class="toc-text">LSTM</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%93%E8%A7%A3%E6%A2%AF%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">如何缓解梯度问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GRU"><span class="toc-number">3.2.3.</span> <span class="toc-text">GRU</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">循环神经网络语言模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%8B%86%E8%A7%A3-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">模型拆解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">损失函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%88%B0%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">序列到序列模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Encoder-Decoder"><span class="toc-number">4.1.</span> <span class="toc-text">Encoder-Decoder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Attention"><span class="toc-number">4.2.</span> <span class="toc-text">Attention</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">4.2.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Additive-Attention"><span class="toc-number">4.2.2.</span> <span class="toc-text">Additive Attention</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transformer"><span class="toc-number">5.</span> <span class="toc-text">Transformer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF-1"><span class="toc-number">5.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81"><span class="toc-number">5.2.</span> <span class="toc-text">位置编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">5.2.1.</span> <span class="toc-text">位置编码的计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">重要性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Self-Attention"><span class="toc-number">5.3.</span> <span class="toc-text">Self-Attention</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">5.3.2.</span> <span class="toc-text">各矩阵的含义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multi-head-Attention"><span class="toc-number">5.4.</span> <span class="toc-text">Multi-head Attention</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E4%B9%89-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">意义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Masked"><span class="toc-number">5.5.</span> <span class="toc-text">Masked</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E4%B9%89-2"><span class="toc-number">5.5.1.</span> <span class="toc-text">意义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Add-Norm"><span class="toc-number">5.6.</span> <span class="toc-text">Add &amp; Norm</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E4%B9%89-3"><span class="toc-number">5.6.1.</span> <span class="toc-text">意义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">5.7.</span> <span class="toc-text">模型架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Encoder"><span class="toc-number">5.7.1.</span> <span class="toc-text">Encoder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Decoder"><span class="toc-number">5.7.2.</span> <span class="toc-text">Decoder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA"><span class="toc-number">5.7.3.</span> <span class="toc-text">模型输出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83"><span class="toc-number">5.8.</span> <span class="toc-text">模型训练</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETrm%E7%9A%84%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">基于Trm的预训练语言模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">预训练语言模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="toc-number">6.1.1.</span> <span class="toc-text">预训练</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">预训练模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">使用模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ELMo"><span class="toc-number">6.2.</span> <span class="toc-text">ELMo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%8D%E5%90%91%E9%87%8F%E7%94%9F%E6%88%90"><span class="toc-number">6.2.2.</span> <span class="toc-text">词向量生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">6.2.3.</span> <span class="toc-text">局限性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B1%95"><span class="toc-number">6.3.</span> <span class="toc-text">发展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BERT-%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">BERT 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-1"><span class="toc-number">7.2.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83-1"><span class="toc-number">7.3.</span> <span class="toc-text">模型训练</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E6%8E%A9%E7%A0%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.4.</span> <span class="toc-text">语言掩码模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E5%8F%A5%E9%A2%84%E6%B5%8B"><span class="toc-number">7.5.</span> <span class="toc-text">下一句预测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%A1%A8%E7%A4%BA"><span class="toc-number">7.6.</span> <span class="toc-text">输入表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E8%B0%83-%E4%B8%8B%E6%B8%B8%E4%BB%BB%E5%8A%A1%E6%94%B9%E9%80%A0"><span class="toc-number">7.7.</span> <span class="toc-text">微调-下游任务改造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A5%E5%AF%B9%E5%88%86%E7%B1%BB"><span class="toc-number">7.7.1.</span> <span class="toc-text">句对分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%8F%A5%E5%88%86%E7%B1%BB"><span class="toc-number">7.7.2.</span> <span class="toc-text">单句分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E9%97%AE%E7%AD%94"><span class="toc-number">7.7.3.</span> <span class="toc-text">文本问答</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%8F%A5%E6%A0%87%E6%B3%A8"><span class="toc-number">7.7.4.</span> <span class="toc-text">单句标注</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By 15H</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>