<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>不平衡数据——SMOTE及其改进算法的比较研究</title>
      <link href="/2025/04/29/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94SMOTE%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6/"/>
      <url>/2025/04/29/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94SMOTE%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="背景">背景</h4><p>​不平衡数据集是机器学习特别是分类器模型训练过程中普遍存在的挑战，尤其是在异常检测领域，比如医疗检测、欺诈信息检测等，我们更加关注的是异常类，然而异常数据的发生概率较小，最终导致训练数据中的类别不平衡。当一个类别中的样本数量明显超过另一类时，模型往往会偏向大多数样本，从而导致性能不佳。</p><p>​针对数据不平衡问题，可以通过调整损失函数，使模型在少数类出错时承担更高的代价，从而引导模型更多关注少数类。同时，也可以直接从数据源头进行干预，修改数据集以缓解不平衡。具体来说，常用的两种方法是：</p><ol><li class="lvl-3"><p>欠采样：通过随机删除或基于某种规则减少多数类样本数量，缺点是删除样本可能会损失有意义的信息</p></li><li class="lvl-3"><p>过采样：通过复制样本或利用样本生成技术增加少数类样本数量，缺点是引入噪声，通过复制而来的样本可能使得模型对某些类别过于敏感</p></li></ol><p>这里我们主要介绍传统的过采样技术——SMOTE，及其改进算法。</p><h5 id="性能指标">性能指标</h5><p>​在一般情况下，许多分类算法的目标是最大限度的提高分类准确率，而分类准确率是一个偏向多数类的指标。在上文我们提到，异常样本的占比机极小，假定只有0.1%是不合法的，那么什么都不做将所有样本都认为是合法的正确率也有99.9%，但这无疑是没有任何意义的。所以我们需要更适合针对数据不平衡问题的评价指标，<strong>混淆矩阵</strong>是最基本、最直观、计算最简单的方法。</p><p><img src="https://files.catbox.moe/bowh2y.png" alt="bowh2y.png"></p><ul class="lvl-0"><li class="lvl-2"><p>精准率：所有被预测为阳性的样本中真实阳性的占比，强调<strong>预测结果的可靠性</strong>。</p></li><li class="lvl-2"><p>召回率/敏感度：所有阳性样本被正确预测为阳性的概率，强调<strong>不能漏掉真正的</strong>。</p></li><li class="lvl-2"><p>特异性：所有阴性样本被正确预测为阴性的概率，强调<strong>不误伤好人</strong>。</p></li></ul><p>​精准率与召回率看上去类似，但实际意义截然不同。当精准率高时，表明预测结果很精准，但可能很多阳性没有被发现；当召回率高时，表明发现了越多的阳性，但可能将部分阴性预测为阳性，导致精准率不那么高。所以，这两者是很难求得两全的标准，为了综合精准率和召回率二者的表现，出现了F1分数，计算公式如下。</p><p>$$\begin{aligned}F1-Score=2\times\frac{Precision\times Recall}{Precision+Recall}\end{aligned}$$</p><p>​从公式可以看出，F1 指标对精准率和召回率的权重是相等的，二者并未偏向任何一方。如果需要对精准率和召回率的重要性进行权衡，还可以使用加权的 $F-measure$——F1 的广义形式，$\beta=1$时即为F1，$\beta&gt;1$则更重视召回率，反之则更重视精准率。</p><p>$$\begin{aligned}F-measuer=(1+\beta^2)\frac{Precision\times Recall}{(\beta^2\cdot Precision)+Recall}\end{aligned}$$</p><p>​上文中提到的精准率、召回率等等指标都是只关注阳性的识别质量，在一些场景如信用卡欺诈检测，我们也不能只关注正类，要同时保证正类和负类都很好才能得到高分，这是G-mean就派上用场。</p><p>$$G-mean=\sqrt{Recall\times Specificity}$$</p><p>​</p><h4 id="SMOTE">SMOTE</h4><h5 id="介绍">介绍</h5><p><a href="https://www.jair.org/index.php/jair/article/view/10302">论文地址</a></p><p>​英文全称 Synthetic Minority Over-Sampling Technique，即<strong>合成少数类过采样技术</strong>，是一种十分经典的过采样技术。正如其名，旨在通过在<strong>特征空间</strong>生成新的少数类样本来弥合差距。简易流程如下图所示。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/013e555815630f60a13a69e073294580.png" alt="img"></p><h5 id="具体实现">具体实现</h5><ol><li class="lvl-3"><p>首先统计各类别的样本数量，识别出少数类样本</p></li><li class="lvl-3"><p>选定一个少数类样本点，找到它在特征空间内距离最近的K个少数类邻居</p></li><li class="lvl-3"><p>随机选择一个邻居，在原样本和邻居之间连线，并在该线上进行随机位置插值，生成新的少数类样本。</p></li></ol><p>$$X_{new}=X_i+\lambda\times(X_{ni}-X_i)$$</p><p>其中$X_i$为选定的样本，$X_{ni}$为随机选择的邻居，$\lambda\in(0,1)$</p><h5 id="缺点">缺点</h5><ul class="lvl-0"><li class="lvl-2"><p>虽然通过线性插值的方式避免了直接复制带来的过拟合风险，但是如果少数类分布本身比较分散，线性插值可能生成不合理样本即引入噪声。</p></li><li class="lvl-2"><p>无法解决类别重叠问题，少数类与多数类在特征空间重叠严重，SMOTE可能会进一步加剧混淆。</p></li><li class="lvl-2"><p>对所有少数类样本一视同仁，并未考虑近邻样本的类别信息，往往出现样本混叠现象。</p></li><li class="lvl-2"><p>在存在噪声的情况下，可能会在多数区域生成少数样本，加剧了类内部平衡现象，如下图所示。</p></li></ul><img src="https://files.catbox.moe/gauk4w.png" alt="gauk4w.png" style="zoom:67%;" /><h4 id="Borderline-SMOTE">Borderline-SMOTE</h4><h5 id="介绍-2">介绍</h5><p><a href="https://link.springer.com/chapter/10.1007/11538059_91">论文地址</a></p><p>​是在SMOTE基础上改进的算法，仅使用边界上的少数类样本合成新样本，从而改善样本的类别分布。更具体地，Borderline-SMOTE作出的改进如下：</p><p>​传统smote对所有少数类样本进行过采样；而bl-smoe会先根据邻近样本的类别信息对少数类样本进行如下分类，其中重点关注<strong>危险区域</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Safe安全区域：最近邻中多数类的数量少于一半，认为<strong>少数类聚集且远离多少类</strong>，不必生成样本徒增计算量</p></li><li class="lvl-2"><p>Danger危险区域：最近邻中多少类数量超过一半但不全是，认为<strong>样本靠近边界，容易被错误分类</strong></p></li><li class="lvl-2"><p>Noise噪声区域：最近邻中全部是多数类样本，认为该样本为噪声样本</p></li></ul><h5 id="实现细节">实现细节</h5><p>Borderline-SMOTE1：从危险区域的每个样本的k个<strong>少数类</strong>最近邻中随机选择s个，生成合成样本，沿样本与其最近邻之间的线段插值。</p><p>Borderline-SMOTE2添加额外改进：利用最近的多数类邻居进行插值，但$\lambda\in(0,0.5)$，即更靠近少数类，避免类间重叠。</p><p>采样前后对比</p><p><img src="https://files.catbox.moe/d7u0a8.png" alt="d7u0a8.png"></p><h4 id="ADASYN">ADASYN</h4><h5 id="介绍-3">介绍</h5><p><a href="https://ieeexplore.ieee.org/document/4633969?arnumber=4633969">论文地址</a></p><p>​全称 adaptive synthetic sampling，即自适应合成抽样，与Borderline-SMOTE相似，同样是基于&quot;SMOTE在合成样本时对所有少数类一视同仁&quot;这一问题加以改进。而<strong>ADASYN</strong>提出，要<strong>重点照顾分类困难的少数类样本</strong>，让模型自适应地更关注这些“难学”的地方。核心思想：</p><ul class="lvl-0"><li class="lvl-2"><p>对于周围多数类较多的少数类，类似bl-smote中的危险区域，被认为是<strong>难学</strong>，生成更多的合成样本</p></li><li class="lvl-2"><p>而对于周围多数类较少的少数类，类似bl-smote中的安全区域，被认为是易学的，生成较少或不生成合成样本</p></li></ul><h5 id="算法流程">算法流程</h5><h6 id="参数说明">参数说明</h6><ul class="lvl-0"><li class="lvl-2"><p>$m_l,m_s$分别为多数类和少数类样本数</p></li><li class="lvl-2"><p>$d_{th}$ 最大容忍阈值</p></li><li class="lvl-2"><p>$\beta$  最终数据集平衡程度</p></li></ul><h6 id="处理过程">处理过程</h6><ol><li class="lvl-3"><p>计算不平衡度</p></li></ol><p>$$d=\frac{m_s}{m_l}$$</p><ol start="2"><li class="lvl-3"><p>检查是否需要生成合成样本，$d&lt;d_{th}$ 说明数据集不平衡程度超出了容忍阈值，需要生成合成样本。</p></li><li class="lvl-3"><p>计算样本数量总数</p></li></ol><p>$$G=(m_l-m_s)\times\beta$$</p><ol start="4"><li class="lvl-3"><p>计算学习难度</p></li></ol><p>$$r_i=\frac{\Delta_i}K$$</p><p>其中 $\Delta_i$ 是K近邻中多数类样本数。$r_i$反映了样本的学习难度，即周围多数类越多，学习难度越大。</p><ol start="5"><li class="lvl-3"><p>归一化学习难度，此时$\hat{r_i}$可以看作是概率分布，表示每个少数类样本的<strong>相对权重</strong></p></li></ol><p>$$\hat{r}<em>i=\frac{r_i}{\sum</em>{i=1}^{m_s}r_i}$$</p><ol start="6"><li class="lvl-3"><p>根据学习难度分配合成样本数</p></li></ol><p>$$g_i=\hat{r_i}\times G$$</p><ol start="7"><li class="lvl-3"><p>生成合成样本，在K近邻中随机选择一个少数类样本 $x_{zi}$</p></li></ol><p>$$x_new=x_i+(x_{zi}-x_i)\times\lambda$$</p><p>采样前后对比</p><p><img src="https://files.catbox.moe/kl8nhq.png" alt="kl8nhq.png"></p><h5 id="评价">评价</h5><p>​从算法流程上可以看出，同样是关注少数类样本周围的样本数量，ADAYSN的适应性更强，并不是硬性区分周围多数类样本超过半数的区域为危险区域，而是利用<strong>学习难度</strong>这一标准加以权衡，让少数类样本之间有着更高的区分度，而不只是简单的危险和安全。</p><h4 id="算法比较">算法比较</h4><p><a href="https://www.diva-portal.org/smash/record.jsf?pid=diva2%3A1519153&amp;dswid=-1899">论文地址</a></p><p>​该论文对SMOTE和ADASYN算法进行比较分析，主要探究预处理方法、分类器的选择和数据的不平衡程度对模型性能的影响程度。</p><p>​过采样设定为使少数类和多数类的样本数尽可能相等，分类模型选择逻辑回归、随机森林、支持向量机。</p><h5 id="实验结果分析">实验结果分析</h5><p>​总体上来看，SMOTE和ADAYSN在绝大多数情况都能显著提高分类器性能，表明过采样有效改善了少数类的预测能力。但是并没有一种预处理方法在所有场景下始终优于另一种</p><h6 id="模型的影响">模型的影响</h6><ul class="lvl-0"><li class="lvl-2"><p>SVM 随着不平衡程度的增加，SMOTE+SVM的组合表现更佳且均优于ADAYSN</p></li><li class="lvl-2"><p>RF  ADAYSN表现较优，随着不平衡程度增加，性能提升更明显</p></li><li class="lvl-2"><p>LR  在不平衡程度最高的信用卡欺诈数据中，过采样反而降低了性能，可能是由于合成样本引入了噪声</p></li></ul><h5 id="讨论">讨论</h5><p>​过采样率统一设为完全平衡（50:50），可能不适用于所有数据集，论文建议在某些场景下尝试较低的过采样率或使用其他方法以减少合成样本的负面影响。</p><p>​实际上，更加值得考虑的问题是，Borderline-SMOTE和ADAYSN都只是针对“传统SMOTE合成样本时对所有少数类一视同仁“这一问题进行改进，并没有解决生成不合理样本和类别重叠问题，单纯的过采样反而加重<strong>边界模糊</strong>，特别是在少数类样本分散或存在离群点时。</p><h4 id="K-means-SMOTE">K-means SMOTE</h4><h5 id="研究背景">研究背景</h5><p><a href="https://linkinghub.elsevier.com/retrieve/pii/S0020025518304997">论文地址</a></p><p>​引言部分指出，在类不平衡的情况下，改进分类技术可以分为三大类：算法级方法、数据级方法、成本敏感方法。算法级方法受限于分类器，相比之下，对成本敏感的方法旨在为每个类别提供不同误分类成本的分类算法。这就需要了解误分类成本，而误分类成本取决于数据集，通常是未知的或难以量化的。所以，数据级方法因其通用性得以普遍适用。</p><p>​数据集方法可以进一步划分为随机方法和知情方法。随机方法是随机选择要删除和复制的样本，而知情方法则不同。它考虑到了样本的分布情况。这样，有信息的方法就能将精力集中在输入空间的关键区域，例如Borderline-SMOTE中的安全区域。因此，有信息的方法可以避免产生噪音，并能解决类内的不平衡问题。</p><h5 id="介绍-4">介绍</h5><p>结合K-means聚类和SMOTE的过采样方法，旨在消除类间不平衡和类内不平衡问题。</p><blockquote><p>​k-means是一种非常常用的无监督聚类算法，目标将数据划分为K个簇，使得每个簇内的数据点尽可能相似，而不同簇之间的数据点尽可能不同。它的核心思想是<strong>最小化簇内样本的平方误差</strong>。</p><p>算法流程:</p><ol><li class="lvl-3"><p>初始化：随机初始化聚类中心。</p></li><li class="lvl-3"><p>分配样本：每个样本分配到最近的聚类中心，形成K个簇。</p></li><li class="lvl-3"><p>更新中心：重新计算各簇所有点的均值，作为新的聚类中心。</p></li><li class="lvl-3"><p>重度23操作，直到聚类中心不再变化或达到最大迭代次数。</p></li></ol></blockquote><h5 id="算法流程-2">算法流程</h5><h6 id="聚类预处理">聚类预处理</h6><p>​使用k-means聚类算法将整个数据集划分为k个簇，聚类的目的是识别数据的自然分组，为后续的过采样提供结构化的基础。该步骤的核心目标是<strong>识别生成合成样本区域</strong>。</p><h6 id="过滤与采样分配">过滤与采样分配</h6><ol><li class="lvl-3"><p>根据每个簇的不平衡比率选择适合采样的簇，不平衡程度的定义如下</p></li></ol><p>$$\begin{aligned}IR©=\frac{\text{majority count}©+1}{\text{minority count}©+1}\end{aligned}$$</p><p>默认情况下，选择少数类样本占比至少为50%的簇（$IR©&lt;1$），也可以通过$irt$来控制</p><ol start="2"><li class="lvl-3"><p>计算每个簇的稀疏度，作为采样权重，稀疏的少数类簇获得更高的采样权重。下面分别是密度、稀疏度、采样权重,采样数量的计算公式</p></li></ol><p>$$<br>\begin{aligned}<br>&amp;\text{density}(f)=\frac{\text{minority count}(f)}{\text{average minority distance}(f)^{de}} \<br>&amp;\text{sparsity}(f)=\frac1{\text{density}(f)} \<br>&amp;\text{sampling weight}(f)=\frac{\text{sparsity}(f)}{\sum\text{sparsity}(f)} \<br>&amp;\text{number of samples}=\left \lfloor n \times \text{sampling weight}(f) \right \rfloor<br>\end{aligned}<br>$$</p><h6 id="过采样">过采样</h6><p>依然采用样本和邻居之间进行线性插值的方法，随机选择簇内<strong>少数类</strong>样本$\vec{a}$，在其k近邻中随机选择<strong>少数类</strong>样本$\vec{b}$，生成新样本$\vec{x}$，$w\in[0,1]$是随机权重</p><p>$$\vec{x}=\vec{a}+w\times(\vec{b}-\vec{a})$$</p><h5 id="评价-2">评价</h5><p>​观察算法流程，在过滤操作和Borderline-line比较类似，都是对不同少数类样本加以区分或者关注；在生成样本数量分配上，和ADAYSN算法过程比较类似，增加对稀疏区域的采样数量。该算法得以效果显著的原因在于 K-means预处理。</p><p>​K-means是一种<strong>无监督</strong>的聚类方法，不依赖于类标签，直接对整个输入空间进行聚类。这允许算法发现<strong>类重叠区域</strong>，并通过过滤步骤排除这些区域，仅在少数类主导的簇内过采样。如下图所示，最终得到过采样数据校正决策边界。</p><p><img src="https://www.helloimg.com/i/2025/04/29/6810e299cc890.png" alt="6810e299cc890.png"></p><p>SMOTE和k-means SMOTE过采样之后的数据分布对比，可以明显看出k-means SMOTE避免在重叠区域生成样本，保护了决策边界的清晰性，改善分类器的泛化能力。</p><p><img src="https://www.helloimg.com/i/2025/04/29/6810d65055836.png" alt="6810d65055836.png"></p><p>与其它聚类算法的比较</p><ul class="lvl-0"><li class="lvl-2"><p>CURE-SMOTE：使用层次聚类清除噪声，但其复杂度较高，未解决类内不平衡问题</p></li><li class="lvl-2"><p>SOMO：将数据映射到二维空间，增加了预处理的复杂性，还可能丢失掉高维信息</p></li><li class="lvl-2"><p>Cluster-SMOTE：仅聚类少数类样本，无法识别类重叠区域，K-means的全局聚类更加全面</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据不平衡 </tag>
            
            <tag> 过采样 </tag>
            
            <tag> SMOTE </tag>
            
            <tag> Borderline-SMOTE </tag>
            
            <tag> ADAYSN </tag>
            
            <tag> SMOTE改进 </tag>
            
            <tag> KMeansSMOTE </tag>
            
            <tag> K-means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马尔可夫链</title>
      <link href="/2025/04/28/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"/>
      <url>/2025/04/28/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="马尔可夫链">马尔可夫链</h3><h4 id="随机过程">随机过程</h4><p>概率论的研究对象是静态的随机现象，而随机过程的研究对象是随时间演变的随机现象（天气随着时间的变化）。在随机过程中，随机现象在某时刻$t$的取值用$S_t$表示，所有可能的状态组成状态集合$S$。</p><h4 id="马尔可夫性质">马尔可夫性质</h4><p>当且仅当某时刻的状态只取决于上一个时刻的状态时，一个随机过程被称为具有<strong>马尔可夫性质</strong>。更系统地，当前状态是未来的充分统计量，而不会受到过去状态的影响。但是这并不代表和历史完全没有关系，实际上当前状态也受到了上一状态的影响，正是通过这种链式关系将历史信息的影响传递到了现在。显然，这一性质可以大大简化计算。</p><h4 id="马尔可夫过程">马尔可夫过程</h4><p>又叫马尔可夫链，即满足马尔可夫性质的随机过程，通常用一个<strong>有限状态集合</strong>和一个<strong>状态转移矩阵</strong>来表示。直观地，马尔可夫链可以看作一个有向图，其中每条边的权值表示从发出状态到接受状态之间的转移概率，所以状态转移矩阵其实可以说是邻接矩阵。</p><h4 id="静态分布">静态分布</h4><p>马尔可夫链在长时间运行后达到的一种稳定状态的概率分布。直观地，假设静态分布为 $\pi$，意味着经过足够长的时间后，系统状态的分布不再变化且每个状态$s_i$出现的概率为 $\pi_i$</p><h5 id="为什么？">为什么？</h5><p>假设状态转移矩阵为 $A$， $P_{ij}(n)$ 表示状态$i$到$j$且恰好经过$n$步的概率</p><p>$$\begin{aligned}P_{i}j(n)&amp;=\sum_kP_{ik}®\times P_{kj}(n-r)\&amp;=A_{ij}^n\end{aligned}$$</p><p>随着步数的增加，初始状态的影响越来越小，最终整个系统的行为只由转移该来本身决定。所以转移矩阵在经过多次幂运算后逐渐趋于稳定，如下式子所示。每一行都是正态分布$\pi$，所以无论起点如何（处于矩阵的那一行），在经过足够长的时间后（$n\to\infty$)，落到所有状态的概率都是固定的（每一列的取值都相等）。</p><p>$$\lim_{n\to\infty}A^n=\begin{bmatrix}\pi\\pi\\vdots\\pi\end{bmatrix}$$</p><p>当然，静态分布并不是在所有情况下都成立，需要满足以下条件</p><ul class="lvl-0"><li class="lvl-2"><p>可约性，所有状态必须是互相到达的</p></li><li class="lvl-2"><p>无周期性，不会被卡在循环内</p></li></ul><p>也就是说，满足静态分布性质的马尔可夫链所构成的图是一个<strong>无环的强连通图</strong>。</p><h3 id="MM用于文本生成任务">MM用于文本生成任务</h3><p>上面提到的<strong>状态</strong>可以表示为文本中的词，根据马尔可夫性质，仅通过当前词来预测下一个词 。一种比较简单的想法为，在大量样本数据上学习到各个词语之间的转移概率，从给定起始词出发进行随机漫步从而达到生成文本的效果。虽然生成的文本大多数是无意义的，但是大多数都是语法正确的。因为语法成分具有很强的前后依赖关系，比如形容词后大多是名词，名词后大多是动词等。</p><h3 id="HMM-隐马尔可夫模型">HMM_隐马尔可夫模型</h3><h4 id="介绍">介绍</h4><p>HMM 是一种可用于标注任务的机器学习模型，描述由隐藏的马尔可夫链随机生成观测序列的过程，属于生成模型。</p><p>HMM 包含 隐藏的即不可观测的序列 和 可观测序列，隐藏序列具有 马尔可夫性质，即当前状态仅有上一状态决定。其中，可观测序列仅由当前的隐藏状态决定，模型的目标是<mark>通过可观测序列找到最有可能的隐藏状态序列</mark>。实际上，刚才的的描述已经了包含了 HMM 的两个关键假设，即 <strong>马尔可夫假设和观测独立性假设</strong>。</p><h4 id="模型描述">模型描述</h4><p>包含隐藏状态集合，观测状态集合，初始概率，转移概率和发射概率。初始概率即为稳态分布，发射概率即为从隐藏状态到观测状态的概率。</p><h4 id="序列标注">序列标注</h4><h5 id="解释性">解释性</h5><p>在标注任务中，<strong>可观测序列就是文本，隐藏状态序列就是所求的标签</strong>。我们有充分理由认为，当前词的词性或者槽仅有前一个词的词性或者槽标签决定，也就是说<mark>马尔可夫假设是有说服力的</mark>。在语料库中，我们也可以学习到各词性或者槽标签出现最多的词是哪些，所以发射概率是可求的。</p><ul class="lvl-0"><li class="lvl-2"><p>转移概率：描述了&quot;上一个标签是什么，接下来可能是什么标签&quot;</p></li><li class="lvl-2"><p>发射概率：描述了“这个标签下，出现这个观测值的可能性”</p></li></ul><h5 id="具体应用">具体应用</h5><ul class="lvl-0"><li class="lvl-2"><p>首先，从语料库中学习到不同词性或者槽标签的之间的转移概率，再通过这个概率求出稳态分布</p></li><li class="lvl-2"><p>其次，统计各个词性或者槽标签下出现某词的概率即发射概率</p></li></ul><p>有了这三个概率后，就可以根据给定的 观测值即输入序列 得到 隐藏状态序列即标签序列，假设$X$为可观测序列，$Y$为隐藏状态序列，对问题进行概率建模，再利用贝叶斯定理进行展开。</p><p>$$\begin{aligned}&amp;argmax_{X=X_1,X_2,\ldots,X_n}P(X=X_1,X_2,\ldots,X_n\mid Y=Y_1,Y_2,\ldots,Y_n)\&amp;=argmax_{X=X_1,X_2,\dots,X_n}\frac{P(Y|X)P(X)}{P(Y)}\end{aligned}$$</p><p>$$\begin{aligned}&amp;P(Y|X)=P(Y_1|X_1)<em>P(Y_2|X_2)</em>\dots P(Y_n|X_n)=\prod P(Y_i|X_i)\&amp;P(X)=\prod P(X_i|X_i-1)\end{aligned}$$</p><p>$$argmax_{X=X_1,X_2,…X_n}\prod P(Y_i\mid X_i):P(X_i\mid X_{i-1})$$</p><h5 id="维特比算法">维特比算法</h5><p>本质是一种<mark>动态规划</mark>算法</p><p>参数说明：</p><ul class="lvl-0"><li class="lvl-2"><p>$\pi(i)$ 为$S_i$初始概率</p></li><li class="lvl-2"><p>$P_1(i,j)$ $S_i$到$S_j$的转移概率</p></li><li class="lvl-2"><p>$P_2(i,O_t)$ 表示$S_i$生成观测值$O_t$的发射概率</p></li></ul><p>状态定义：</p><ul class="lvl-0"><li class="lvl-2"><p>$\delta_t(j)$ 时间$t$时到达$S_j$的最大概率</p></li><li class="lvl-2"><p>$\psi_t(j)$ 记录上一时刻的状态，用于回溯找出路径</p></li></ul><p>状态转移矩阵：</p><p>$$\begin{aligned}\delta_t(j)=\max_i\left(\delta_{t-1}(i)\times P_1(i,j)\right)\times P_2(j,O_t)\\psi_t(j)=\arg\max_i\left(\delta_{t-1}(i)\times P_1(i,j)\right)\end{aligned}$$</p><p>路径回溯：</p><p>$$\begin{aligned}q_T<sup>*=\arg\max_j\delta_T(j)\q_{t-1}</sup><em>=\psi_t(q_t^</em>)\quad(t=T,T-1,\ldots,2)\end{aligned}$$</p><h3 id="MEMM-最大熵马尔可夫模型">MEMM_最大熵马尔可夫模型</h3><h4 id="背景">背景</h4><h5 id="HMM-的缺陷">HMM 的缺陷</h5><p>在 HMM 中提到，HMM 解决的任务的需要满足 马尔可夫假设 和 观测独立性建设。在序列标注任务中，马尔可夫假设是很有说服力的，即当前标签仅跟标签仅跟上一个标签有关，不需要更早的标签。</p><p>但是观测独立性假设意味着，观测值只依赖于当前隐藏状态，虽然有一定的可解释性，但过于简单并不能自由地利用上下文信息。在实际情况中，往往需要更多的特征。HMM并不能很好的利用丰富特征</p><h4 id="最大熵原理">最大熵原理</h4><p>在已知部分信息的情况下，对未知概率分布进行推断或选择的原则。核心思想是，在所有满足已知约束条件的概率分布中，选择那个<strong>熵最大</strong>的分布作为最佳或最合理的推断。</p><p>应用：对于多种复杂特征，我们并不知道哪些特征能够更好的辅助预测当前词性，所以做出最无偏的估计，最大化不确定性，保留最大的可能性空间，最大程度上避免引入不必要的假设。</p><h4 id="优缺点">优缺点</h4><h5 id="优点">优点</h5><p>灵活加入任意特征，通过最大化不确定性来避免主观假设，还降低过拟合风险。这是 MEMM 相对于 HMM 的巨大优势。它可以把当前观测的各种特征（比如词本身、词根、词缀、大小写、是不是数字、前后词是什么等） 都作为线索，帮助预测当前词性。HMM 则很难利用这么多交叉重叠的特征。</p><h5 id="标注偏见">标注偏见</h5><p>局部最优解不一定走向全局最优解。虽然相比HMM添加了很多特征，但决策依然是局部的，在上一个状态的基础上，结合特征向前推进，从而忽略了全局最优的决策。从HMM的求解算法中我们提到，维特比算法本质是一种动态规划算法，而动态规划能够求解最优解的前提是<strong>问题最优解可以由子问题的最优解推导出来</strong>，在复杂的序列标注问题中，显然不满足这一特点。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HMM </tag>
            
            <tag> HEMM </tag>
            
            <tag> 序列标注 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本数据处理方法</title>
      <link href="/2025/04/27/%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
      <url>/2025/04/27/%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是特征工程？">什么是特征工程？</h3><p>简单来说是对数据进行处理，为模型提供有效的输入表示</p><p>目的：将文本、图像等原始数据转成数字化、结构化的形式供模型使用，在 nlp 任务则主要针对文本数据</p><h3 id="传统基于统计的方法">传统基于统计的方法</h3><h4 id="BOW">BOW</h4><p>非常经典且简单的文本特征表示方法基本思想：</p><ol><li class="lvl-3"><p>忽略词语的顺序和语法结构，只关注词语的频率特征</p></li><li class="lvl-3"><p>将文本转为固定长度的向量</p></li></ol><p>步骤：</p><ol><li class="lvl-3"><p>统计并去重训练文本中所有单词，构成词汇表</p></li><li class="lvl-3"><p>针对单一文本，统计每个词的出现次数形成文本特征向量</p></li></ol><p>最终形成的向量长度等于词汇表的大小，对应位置表示对应单词的出现次数</p><h5 id="评价">评价</h5><p>优点：简单高效易实现</p><p>缺点：忽略单词顺序和语法结构、无法处理训练数据中未出现的词，最终向量高维稀疏</p><h4 id="TF-IDF">TF-IDF</h4><p>实际上是一种<strong>加权技术</strong>， 评估一字词对于整个语料库的重要程度</p><p>基本思想是：如果只在某一篇文章中词频高，而在其余文章中很少出现，则可以认为其具有很好的类区分能力，适合用来分类</p><p>两个指标 TF是词频(Term Frequenc)，IDF是逆向文件频率(Inverse Document Frequency)</p><p>$$\begin{aligned}&amp;TF(t,d)=\frac{f(t,d)}{N(d)}\&amp;IDF(t)=log(\frac N{D_t+1})\end{aligned}$$</p><p>通过计算公式可以看出，TF表示词语在当前文档的重要性，而 IDF 衡量了词语在整个文档/语料库的重要性<br>$$TF-IDF_{t,d}=TF(t,d)\times IDF(d)$$</p><p>主要应用：搜索引擎、关键词提取、文本相似性、文本摘要</p><h3 id="基于推理-预测的方法">基于推理/ 预测的方法</h3><h4 id="词向量">词向量</h4><p>定义：将单词映射到低维连续向量空间的方式，通过训练模型来获得每个单词的向量表示</p><p>作用：将原本稀疏且高维的矩阵转变为低维且连续的矩阵，一般为100~300维</p><p>特点：词向量内积或余弦表示单词间的相似性。也就是说如果两个词的语义很相近，那么它们的空间位置越近</p><p>注意：在实际运用中可以选择使用在大型语料库中预训练的词向量，但这对于一些垂直领域的任务可能不太适用，因为预训练的词向量可能无法很好地捕捉特定领域的语义信息</p><img src="https://files.catbox.moe/q4yll6.png" alt="q4yll6.png|610" style="zoom: 67%;" /><h5 id="迁移学习">迁移学习</h5><p>根据向量空间位置分布的特点，词向量或者说单词的分布式表示可以用来查找近似单词，但其使用场景还远不止此，其中一个非常重要的作用就是<strong>迁移学习</strong>——指在某个领域学习到的知识可以被应用于其它领域。</p><p>在上述提供的传统的基于统计的方法，更多的关注词频等信息，对任务的耦合程度极高，可以说脱离了原有训练数据就毫无意义。但是，在几乎所有类型的自然语言处理任务（分类、聚类、标注和情感分析等），单词的分布式表示都有很好的效果。</p><p>正因如此，虽然后面会花费大篇幅介绍词向量的训练过程，但是大多数时候我们可以直接使用在大型语料库中学习好的词向量。</p><h4 id="Word2Vec">Word2Vec</h4><p>一种学习词向量的方法有以下两种训练方法，利用神经网络，通过最大化预测内容的正确性来<strong>学习</strong>到词向量表示。</p><p><img src="https://www.helloimg.com/i/2025/04/27/680e123707cb8.png" alt="680e123707cb8.png"></p><h5 id="CBOW">CBOW</h5><p>连续词袋模型，通过上下文来预测中间词，下图可以简单描述这一过程。在自然语言处理领域，理解单词的含义通常需要考虑上下文，因为上下文提供单词用法和语义的重要线索。</p><h6 id="损失函数">损失函数</h6><p>为了简单起见，我们先只考虑上下文窗口为1的情况，即只取前后1个单词</p><p>概率建模：$P(w_t|w_{t-1},w_{t+1})$ 表示 “给定上下文$w_{t-1},w_{t+1}$时目标词为$w_t$的概率&quot;</p><p>套用<strong>交叉熵误差函数</strong>，得到如下公式</p><p>$$L=-\frac1T\sum_{t=1}^T\log P(w_t|w_{t-1},w_{t+1})$$</p><p>学习的任务就是让上式表示的损失函数尽可能小</p><h5 id="skip-gram">skip-gram</h5><p>跳元模型，与CBOW 完全相反，通过单词来预测上下文</p><h6 id="损失函数-2">损失函数</h6><p>为了简单起见，我们依然只考虑上下文窗口为1的情况，即预测结果为前后1个词</p><p>由于输出层不止一个，因此损失函数要计算各输出层的总和</p><p>概率建模：$P(w_{t-1},w_{t+1}|w_t)$ 表示 “给定$w_t$时，$w_{t-1},w_{t+1}$同时出现的概率”</p><p>同样使用交叉熵误差函数，如果只考虑上述情况</p><p>$$\begin{aligned}L&amp;=-\log P(w_{t-1},w_{t+1}|w_{t})\&amp;=-\log P(w_{t-1}|w_t)P(w_{t+1}|w_t)\&amp;=-(\log P(w_{t-1}|w_t)+\log P(w_{t+1}|w_t))\end{aligned}$$</p><p>推广到整个语料库</p><p>$$L=-\frac1T\sum_{t=1}^T(\log P(w_{t-1}|w_t)+\log P(w_{t+1}|w_t))$$</p><h5 id="两种方法的比较">两种方法的比较</h5><p>从CBOW和skip-gram预测过程上看：CBOW通过中间词对周围词进行调整，预测次数跟整个文本的次数基本是相等。而在skip-gram中，每个词作为输入时，都会受到周围词的影响，相当于比CBOW多进行了K次，K为上下文窗口大小。</p><p>所以，skip-gram训练出的词向量往往会有更好的表现，但是计算成本较高。</p><h4 id="Word2Vec-高速化">Word2Vec 高速化</h4><p>word2vec的实现原理和训练过程都比较简单。但是在实际的使用场景中，词表往往有成千上万的单词，词汇量增大所带来的的计算效率问题是当前我们研究的问题。</p><p>实际上，效率问题主要是sfotmax层计算带来的，观察softmax计算公式，分母要进行V次exp计算</p><p>$Softmax(z_i)=\frac{exp(z_i)}{\sum_j^Vexp(z_j)}$</p><p>因此我们需要可以替代softmax的<strong>轻量计算</strong></p><h5 id="负采样">负采样</h5><p>最初被用于加速skip-gram模型训练，后来被广泛用于自然语言处理，计算机视觉和推荐系统中。</p><h6 id="核心思想">核心思想</h6><p>在训练时，不是对所有可能的样本进行训练，而是只针对<strong>正样本和少量随机选出来的负样本</strong>来训练</p><ul class="lvl-0"><li class="lvl-2"><p>正样本：真实的上下文词，模型希望预测<strong>正确</strong>的配对</p></li><li class="lvl-2"><p>负样本：随机的无关词，模型希望预测<strong>错误</strong>的配对</p></li></ul><p>这样一来，模型训练的目的不只是最大化正确的概率，还要最小化负样本正确的概率。</p><p>从任务上来看，我们用<mark>二分类来拟合多分类效果，从&quot;是什么&quot;到&quot;是什么吗&quot;的转变</mark></p><p>带来两个主要好处</p><ul class="lvl-0"><li class="lvl-2"><p>大大减少训练的计算量</p></li><li class="lvl-2"><p>同时关注正确的搭配和错误的搭配</p></li></ul><h6 id="损失函数-3">损失函数</h6><p>在多分类问题中，通常使用softmax将得分转化为概率。而对于二分类问题，并不需要归一化操作，输出层仅使用简单的sigmod函数即可</p><p>$$\sigma=\frac{1}{1+e^{-x}}$$</p><p>$$h=\frac{1}{m}\sum_{i=1}^mv_{c_i}$$</p><p>$$L=-\left(\log\sigma(v_w^\prime\cdot h)+\sum_{k=1}<sup>K\log\sigma(-v_{w_k}</sup>\prime\cdot h)\right)$$</p><p>其中$v$代表学习到的词向量， $h$ 为上下文综合向量，其中前半部分为正采样，后半部分为负采样，$K$为负采样个数</p><h5 id="层次-softmax">层次 softmax</h5><h6 id="核心思想-2">核心思想</h6><p>将词表组织成一棵二叉树</p><ul class="lvl-0"><li class="lvl-2"><p>词表中的每个词放置在叶子节点</p></li><li class="lvl-2"><p>每个中间节点都有自己的词向量</p></li><li class="lvl-2"><p>每经过一个节点，都在做一次二分类</p></li></ul><p>类似于在二叉搜索树上找到指定元素的过程，将复杂度从$O(N)$降低到$O(logN)$</p><h6 id="损失函数-4">损失函数</h6><p>每个节点向下做出决策时依然是二分类，依然使用sigmod函数来表示概率</p><p>$$P(w)=\prod_{i\in path(w)}P(i)$$</p><p>$$L=-\sum_{i\in path(i)}logP(i)$$</p><p>$path(w)$为跟节点到单词为w的叶子节点的路径上的节点集合，$P(i)$为概率</p><p>训练的目标是最大化正确路径上所有节点决策的概率</p><h4 id="Glove">Glove</h4><p>遍历整个语料库来构建共现矩阵，优化目标函数<br>Word2Vec 更关注局部上下文信息，而Glove 语义捕捉更全面</p><h5 id="共现矩阵">共现矩阵</h5><p>在word2vec中，通过滑动窗口选取输入样本</p><p>在Glove中，直接对窗口内的每对词进行词频统计，遍历整个语料库，从而得到共现矩阵</p><h5 id="平滑损失函数">平滑损失函数</h5><p>$$\begin{aligned}<br>J=\sum_{i,j=1}<sup>Vf(X_{ij})(w_i</sup>Tw_j+b_i+b_j-\log(X_{ij})^2) \<br>f(x)=(\frac{x}{x_{max}})^{\alpha} \end{aligned}$$</p><p>其中，$X_{i,j}$ 为特定大小窗口的共现次数，$W_{i,j}$ 表示学习到的词向量</p><p>$f$ 为加权函数，用来调整每个词对损失的贡献，减对于高频词语的过分关注，更好的处理停用词等</p><h4 id="BERT">BERT</h4><p>基于Transformer架构的编码器模型，是一种预训练语言模型，通过预训练大规模语料库来学习语言表示</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word2vec </tag>
            
            <tag> TF-IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2025/04/26/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2025/04/26/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<h2 id="莫比乌斯反演">莫比乌斯反演</h2><h4 id="前言">前言</h4><p>反演实际上是利用莫比乌斯函数实现 <mark>和函数与原函数之间的转换</mark></p><p>我们需要求原函数，而实际上和函数是容易求得的</p><h4 id="常用反演规律">常用反演规律</h4><p>$f(n)表示…为n的方案数\F(n)表示…为n的倍数的方案数\F(n)=\sum_{n|d}f(d)\反演\to f(n)=\sum_{n|d}F(d)\mu(\frac{d}{n})$</p><h4 id="例题">例题</h4><p><a href="https://www.luogu.com.cn/problem/P1390">公约数的和 可以当作模版题</a></p><p>$\sum_{i=1}<sup>n\sum_{j=i+1}</sup>ngcd(i,j)\f(n)=\sum\sum [gcd(i,j)=n]\F(n)=\sum_{n|d}f(d)\反演\to f(n)=\sum_{n|d}F(d)*\mu(\frac{d}{n})\Ans=\sum_{i=1}^nf(i)*i$</p><p>这一题还可以对式子进行变换，对于j=i+1这种和式超级难受</p><p>$\sum_{i=1}<sup>n\sum_{j=i+1}</sup>ngcd(i,j)\times2+\sum_{i=1}<sup>ni=\sum_{i=1}</sup>n\sum_{j=1}^ngcd(i,j)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">getMu</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先算出F[i]的值，公倍数为i的倍数的方案数</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        F[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举倍数，公倍数为j 乘法原理计算方案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            F[i]+=(n/i-j/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举倍数d 根据反演式计算F[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=i;d&lt;=n;d+=i)&#123;</span><br><span class="line">            f[i]+=F[d]*mu[d/i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f[i]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>式子变换之后的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)  F[i]=(n/i)*(n/i);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=i;d&lt;=n;d+=i)&#123;</span><br><span class="line">            f[i]+=F[d]*mu[d/i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f[i]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans-=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">    ans/=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1447">能量采集</a></p><p><a href="https://ac.nowcoder.com/acm/contest/22769/C">序列</a></p><p>$\sum_{i=1}<sup>n\sum_{j=1}</sup>n[gcd(i,j)=1]$</p><p>f(n)表示gcd为n的方案数，F(n)表示gcd为n的倍数的方案数，所求答案即为f(1)</p><p><a href="https://www.luogu.com.cn/problem/P2231">跳蚤</a></p><p>$\sum_{a=1}<sup>m\sum_{b}</sup>m\dots[gcd(a,b,\dots)=1]$</p><p>相同的方法反演，使用乘法原理就可以算出gcd为k的倍数的方案数$\to(\frac{m}{d})^n$</p><p><a href="https://ac.nowcoder.com/acm/contest/22769/E">公约数之和加强版</a></p><p>$\sum_{a=1}<sup>k\sum_{b}</sup>k\dots.gcd(a,b,\dots)$</p><p><a href="https://ac.nowcoder.com/acm/contest/22769/D">LCMS</a></p><p>和式可以变换为 $\sum_{i=1}<sup>n\sum_{j=1}</sup>nlcm(A_i,A_j)$</p><p>$f(n)=\sum_{i=1}<sup>n\sum_{j=1}</sup>n(A_i\times A_j)[gcd(i,j)==n]\F(d’)=\sum_{d’|d}f(d)=\sum_{d’|d}\sum_{i=1}<sup>n[\frac{A_i}{d}]\sum_{j=1}</sup>n[\frac{A_j}{d}] \上面的式子是比较好算的，交叉相乘为和的乘积 \ 反演\to f(n)=\sum_{n|d}F(d)\mu(\frac{d}{n})\ans=\sum_{d=1}^n\frac{1}{d}f(d)$</p><p><a href="https://www.luogu.com.cn/problem/P3911">最小公倍数之和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>(N<span class="number">-10</span>);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    n=mx;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="comment">//两个因数都是i的倍数</span></span><br><span class="line">        <span class="comment">//枚举i的倍数为j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            F[i]+=cnt[j]*j;</span><br><span class="line">            F[i]%=p;</span><br><span class="line">        &#125;</span><br><span class="line">        F[i]*=F[i];</span><br><span class="line">        F[i]%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="comment">//公约数为i的方案数，计算反演式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=i;d&lt;=n;d+=i)&#123;</span><br><span class="line">            <span class="comment">//mu[d/i]可能为负</span></span><br><span class="line">            f[i]=(f[i]+F[d]*mu[d/i]%p+p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+f[i]*inv[i]%p+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans-sum+p)%p;</span><br><span class="line">    ans=ans*inv[<span class="number">2</span>]%p;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分块优化">分块优化</h4><p><a href="https://www.luogu.com.cn/problem/P3455">ZAP Queries</a></p><p>$\sum\sum[gcd(i,j)=d]$ 显然是非常好计算的，但是在多case的情况下，如果不进行优化很容易超时</p><p>优化前</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=d;i&lt;=<span class="built_in">min</span>(a,b);i+=d)&#123;</span><br><span class="line">    F[i]=(a/i)*(b/i);</span><br><span class="line">    ans+=F[i]*mu[i/d];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现F[i]其实可以分块来做，在一定区间内，F[i]的值是不变的，统计莫比乌斯函数区间和即可</p><p>$f(d)=\sum_{d|d’}F(d’)*\mu(\frac{d’}{n})=\sum_{d|d’}\mu(\frac{d’}{d})\frac{a}{d’}\frac{b}{d’}$</p><p>$t=\frac{d’}{d};;ans=\sum_{t}\mu(t)\frac{a}{dt}\frac{b}{dt}$ t时枚举量，实际上除数是a/d,b/d</p><p>$=\sum_{t}\mu(t)\frac{\frac{a}{d}}{t}\frac{\frac{d}{d}}{t}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="built_in">min</span>(a/d,b/d);l=r<span class="number">+1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(a/d/(a/d/l),b/d/(b/d/l));</span><br><span class="line">    ans+=(a/(l*d))*(b/(l*d))*(mu[r]-mu[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a/=d,b/=d;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="built_in">min</span>(a,b);l=r<span class="number">+1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">min</span>(a/(a/l),b/(b/l));</span><br><span class="line">    ans+=(a/l)*(b/l)*(sum[r]-sum[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3312">数表</a></p><p>$\sum_{i=1}<sup>n\sum_{j=1}</sup>m[\varphi(\gcd(i,j))&lt;=a] \quad \varphi(n)=\sum_{d|n}d$</p><p>$\sum_{\varphi(d)\le a}\varphi(d)f(d);;,f(d)=\sum_{n|d}F(d)\mu(\frac{d}{n})$</p><p>$\varphi(d’)\sum_{d’|d}\mu(\frac{d}{n})\frac{n}{d}\frac{n}{d}$ 不需要确保枚举量是d的倍数，使用树状数组求前面一部分前缀和，只有d的倍数才会被添加到树状数组中</p><p>离线查找答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录1e5以下的数据和约数和</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; o)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;o.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUERY</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,a,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> QUERY&amp; o)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;o.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">min</span>(n,m),ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=t;l=r<span class="number">+1</span>)&#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">        <span class="comment">//query只会查到[l,r]区间内d的倍数的位置</span></span><br><span class="line">        ans+=(<span class="built_in">query</span>(r)-<span class="built_in">query</span>(l<span class="number">-1</span>))*(n/l)*(m/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin&gt;&gt;Q[i].n&gt;&gt;Q[i].m&gt;&gt;Q[i].a;</span><br><span class="line">        Q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+100001</span>);</span><br><span class="line">    <span class="built_in">sort</span>(Q<span class="number">+1</span>,Q<span class="number">+1</span>+q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(b[j].sum&lt;=Q[i].a <span class="keyword">and</span> j&lt;=<span class="number">1e5</span>)&#123;</span><br><span class="line">            <span class="comment">//将满足条件的约数和的倍数塞入到树状数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d=b[j].val;d&lt;=<span class="number">1e5</span>;d+=b[j].val)&#123;</span><br><span class="line">                <span class="built_in">add</span>(d,b[j].sum*mu[d/b[j].val]);  </span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        ans[Q[i].id]=<span class="built_in">solve2</span>(Q[i].n,Q[i].m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]&lt;<span class="number">0</span>) ans[i]+=<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筛法和积性函数</title>
      <link href="/2025/04/26/%E7%AD%9B%E6%B3%95%E5%92%8C%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/26/%E7%AD%9B%E6%B3%95%E5%92%8C%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="线性筛筛质数">线性筛筛质数</h4><p>线性筛为什么可以做到线性，它让每个合数只被<strong>最小的质因数</strong>筛选一次而不发生重复筛选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) pri[++cnt]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> pri[j]*i&lt;=<span class="number">1e8</span>;j++)&#123;</span><br><span class="line">        <span class="type">int</span> m=i*pri[j];</span><br><span class="line">        vis[m]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//说明pri[j]是i的最小质因数，同样是被筛数m的最小质因数，所以再后面的数就应该由pri[j]筛掉，而不是j++</span></span><br><span class="line">        <span class="comment">//那么6*3=18应该等到i=9是被pri[j]=2筛掉，所以i=6时遇到pri[j]=2就可以停止了</span></span><br><span class="line">        <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛求约数个数">线性筛求约数个数</h4><p>$$n=\prod_{i=1}<sup>sp_i</sup>{\alpha_i}\qquad ans=\prod_{i=1}^s(\alpha_i+1)$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>,d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">1e7</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            a[i]=<span class="number">1</span>;d[i]=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> i*pri[j]&lt;=<span class="number">1e7</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pri[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                a[m]=a[i]<span class="number">+1</span>;</span><br><span class="line">                d[m]=d[i]/a[m]*(a[m]<span class="number">+1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[m]=<span class="number">1</span>;</span><br><span class="line">                d[m]=d[i]*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛求约数和">线性筛求约数和</h4><p>$n=\prod_{i=1}<sup>sp_i</sup>{\alpha_i}\qquad (n)=\prod_{i=1}<sup>s\sum_{j=0}</sup>{\alpha_i}p_i^j$</p><blockquote><p>a[i]是最小质因数的约数和</p><p>d[i]是函数值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">1e7</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            a[i]=d[i]=i<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> i*pri[j]&lt;=<span class="number">1e7</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pri[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                a[m]=a[i]*p[j]<span class="number">+1</span>;</span><br><span class="line">                d[m]=d[i]/a[i]*a[m]</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[m]=p[j]<span class="number">+1</span>;</span><br><span class="line">                d[m]=d[i]*a[m];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛求莫比乌斯函数">线性筛求莫比乌斯函数</h4><p>莫比乌斯函数：</p><p>包含相同质因子为0</p><p>不同质因数为偶数个为1，奇数为-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">1e7</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> i*pri[j]&lt;=<span class="number">1e7</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pri[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                mu[m]=<span class="number">0</span>;s</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//比i多了一个质因数，奇偶互换0不变，所以取反</span></span><br><span class="line">                mu[m]=-mu[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="莫比乌斯反演">莫比乌斯反演</h5><p>设任意算术函数f, 其和函数为 $F(n)=\sum_{d|n}f(d)$ 即n的所有正因数的函数和称为和函数</p><p>莫比乌斯函数就是<mark>和函数到原函数的反向过程</mark> $f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})$</p><h4 id="线性筛与积性函数">线性筛与积性函数</h4><p>其实上诉问题，因子和$(n)=\sum_{d|n}d$ 和约数个数 $(n)=\sum_{d|n}1$都是积性函数</p><p>积性函数？对于互为质数的正整数p,q有 $(p<em>q)=(p)</em>(q)$</p><p><mark>积性函数都可以用线性筛求解1~n的所有函数值</mark></p><p>O(n)求1~n的欧拉函数是一个比较简单但直观的例子，所以线性筛也被称为欧拉筛</p><p>欧拉函数</p><p>$n=\prod_{i=1}<sup>sp_i</sup>{\alpha_i} \quad (n)=n\prod(1-\frac{1}{p_i})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//单独考虑质数的情况</span></span><br><span class="line">            pr[++cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> pr[j]&lt;=n/i;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pr[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//需要特别判断pq不互质的情况的</span></span><br><span class="line">            <span class="keyword">if</span>(i%pr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//没有出现新的质因数p，就扩大到m就行</span></span><br><span class="line">                phi[m]=phi[i]*pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现了新的质因数</span></span><br><span class="line">                phi[m]=phi[i]*phi[pr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://ac.nowcoder.com/acm/contest/22769/B">完全积性函数 华华给月月出题</a></p><blockquote><p>幂函数对于任何的p,q都满足$(p<em>q)=p</em>q$ 被称为完全积性函数，不需要单独考虑遍历值不为最小质因数的情况</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">        <span class="comment">//单独考虑一下质数就行</span></span><br><span class="line">        pri[++cnt]=i;</span><br><span class="line">        f[i]=<span class="built_in">qpow</span>(i,n,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> pri[j]&lt;=n/i;j++)&#123;</span><br><span class="line">        vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//通过乘性关系递推</span></span><br><span class="line">        f[i*pri[j]]=f[i]*f[pri[j]]%p;</span><br><span class="line">        <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="杜教筛">杜教筛</h4><p>求积性函数的前缀和</p><p>用来调整每个词对损失的贡献，减对于高频词语的过分关注，更好的处理停用词等</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
