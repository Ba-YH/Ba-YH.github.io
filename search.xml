<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文本数据处理方法</title>
      <link href="/2025/04/27/%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
      <url>/2025/04/27/%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是特征工程？">什么是特征工程？</h4><p>简单来说是对数据进行处理，为模型提供有效的输入表示</p><p>目的：将文本、图像等原始数据转成数字化、结构化的形式供模型使用，在 nlp 任务则主要针对文本数据</p><h3 id="传统基于统计的方法">传统基于统计的方法</h3><h4 id="BOW">BOW</h4><p>非常经典且简单的文本特征表示方法基本思想：</p><ol><li class="lvl-3"><p>忽略词语的顺序和语法结构，只关注词语的频率特征</p></li><li class="lvl-3"><p>将文本转为固定长度的向量</p></li></ol><p>步骤：</p><ol><li class="lvl-3"><p>统计并去重训练文本中所有单词，构成词汇表</p></li><li class="lvl-3"><p>针对单一文本，统计每个词的出现次数形成文本特征向量</p></li></ol><p>最终形成的向量长度等于词汇表的大小，对应位置表示对应单词的出现次数</p><h5 id="评价">评价</h5><p>优点：简单高效易实现缺点：忽略单词顺序和语法结构、无法处理训练数据中未出现的词，最终向量高维稀疏</p><h4 id="TF-IDF">TF-IDF</h4><p>实际上是一种<strong>加权技术</strong>，评估一字词对于整个语料库的重要程度</p><p>基本思想是：如果只在某一篇文章中词频高，而在其余文章中很少出现，则可以认为其具有很好的类区分能力，适合用来分类</p><p>两个指标 TF是词频(Term Frequenc)，IDF是逆向文件频率(Inverse Document Frequency)</p><p>$$\begin{aligned}&amp;TF(t,d)=\frac{f(t,d)}{N(d)}\&amp;IDF(t)=log(\frac N{D_t+1})\end{aligned}$$</p><p>通过计算公式可以看出，TF表示词语在当前文档的重要性，而 IDF 衡量了词语在整个文档/语料库的重要性<br>$$TF-IDF_{t,d}=TF(t,d)\times IDF(d)$$</p><p>主要应用：搜索引擎、关键词提取、文本相似性、文本摘要</p><h4 id="N-gram">N-gram</h4><p>基本思想是将文本内容划分为若干长度为 N 的连续片段，每个片段为一个 gram，每一种 gram 是一个特征向量维度<br>N-gram 将文本划分为连续的单词片段，将这些片段作为基本单位</p><h3 id="基于推理-预测的方法">基于推理/预测的方法</h3><h4 id="词向量">词向量</h4><p>定义：将单词映射到低维连续向量空间的方式，通过训练模型来获得每个单词的向量表示</p><p>作用：将原本稀疏且高维的矩阵转变为低维且连续的矩阵，一般为100~300维</p><p>特点：词向量内积或余弦表示单词间的相似性。也就是说如果两个词的语义很相近，那么它们的空间位置越近</p><p>注意：在实际运用中可以选择使用在大型语料库中预训练的词向量，但这对于一些垂直领域的任务可能不太适用，因为预训练的词向量可能无法很好地捕捉特定领域的语义信息</p><img src="https://files.catbox.moe/q4yll6.png" alt="q4yll6.png|670" style="zoom: 67%;" /> <h4 id="Word2Vec">Word2Vec</h4><p>一种学习词向量的方法有以下两种训练方法，利用神经网络，通过最大化预测内容的正确性来<strong>学习</strong>到词向量表示</p><h5 id="CBOW">CBOW</h5><p>连续词袋模型，简单的说就是通过上下文来预测中间词<br><img src="https://files.catbox.moe/tl1qin.png" alt="tl1qin.png|670"></p><h5 id="skip-gram">skip-gram</h5><p>跳元模型，与CBOW 相反，通过单词来预测上下文，损失函数求各个上下文单词的总和</p><h4 id="Glove">Glove</h4><p>遍历整个语料库来构建共现矩阵，优化目标函数<br>Word2Vec 更关注局部上下文信息，而Glove 语义捕捉更全面</p><h5 id="共现矩阵">共现矩阵</h5><p>在word2vec中，通过滑动窗口选取输入样本。</p><p>在Glove中，直接对窗口内的每对词进行词频统计，遍历整个语料库，从而得到共现矩阵</p><h5 id="平滑损失函数">平滑损失函数</h5><p>$$\begin{aligned}<br>J=\sum_{i,j=1}<sup>Vf(X_{ij})(w_i</sup>Tw_j+b_i+b_j-\log(X_{ij})^2) \<br>f(X_{ij})=\begin{cases}(\frac{x}{x_{max}})^\alpha&amp;x&lt;x_{max}\1&amp;otherwise\end{cases}<br>\end{aligned}$$</p><p>其中，$X_{i,j}$ 为特定大小窗口的共现次数，$W_{i,j}$ 表示学习到的词向量<br>$f$ 为加权函数，用来调整每个词对损失的贡献，减对于高频词语的过分关注，更好的处理停用词等</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word2vec </tag>
            
            <tag> TF-IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2025/04/26/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2025/04/26/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<h2 id="莫比乌斯反演">莫比乌斯反演</h2><h4 id="前言">前言</h4><p>反演实际上是利用莫比乌斯函数实现 <mark>和函数与原函数之间的转换</mark></p><p>我们需要求原函数，而实际上和函数是容易求得的</p><h4 id="常用反演规律">常用反演规律</h4><p>$f(n)表示…为n的方案数\F(n)表示…为n的倍数的方案数\F(n)=\sum_{n|d}f(d)\反演\to f(n)=\sum_{n|d}F(d)\mu(\frac{d}{n})$</p><h4 id="例题">例题</h4><p><a href="https://www.luogu.com.cn/problem/P1390">公约数的和 可以当作模版题</a></p><p>$\sum_{i=1}<sup>n\sum_{j=i+1}</sup>ngcd(i,j)\f(n)=\sum\sum [gcd(i,j)=n]\F(n)=\sum_{n|d}f(d)\反演\to f(n)=\sum_{n|d}F(d)*\mu(\frac{d}{n})\Ans=\sum_{i=1}^nf(i)*i$</p><p>这一题还可以对式子进行变换，对于j=i+1这种和式超级难受</p><p>$\sum_{i=1}<sup>n\sum_{j=i+1}</sup>ngcd(i,j)\times2+\sum_{i=1}<sup>ni=\sum_{i=1}</sup>n\sum_{j=1}^ngcd(i,j)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">getMu</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先算出F[i]的值，公倍数为i的倍数的方案数</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        F[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举倍数，公倍数为j 乘法原理计算方案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            F[i]+=(n/i-j/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举倍数d 根据反演式计算F[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=i;d&lt;=n;d+=i)&#123;</span><br><span class="line">            f[i]+=F[d]*mu[d/i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f[i]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>式子变换之后的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)  F[i]=(n/i)*(n/i);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=i;d&lt;=n;d+=i)&#123;</span><br><span class="line">            f[i]+=F[d]*mu[d/i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f[i]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans-=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">    ans/=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1447">能量采集</a></p><p><a href="https://ac.nowcoder.com/acm/contest/22769/C">序列</a></p><p>$\sum_{i=1}<sup>n\sum_{j=1}</sup>n[gcd(i,j)=1]$</p><p>f(n)表示gcd为n的方案数，F(n)表示gcd为n的倍数的方案数，所求答案即为f(1)</p><p><a href="https://www.luogu.com.cn/problem/P2231">跳蚤</a></p><p>$\sum_{a=1}<sup>m\sum_{b}</sup>m\dots[gcd(a,b,\dots)=1]$</p><p>相同的方法反演，使用乘法原理就可以算出gcd为k的倍数的方案数$\to(\frac{m}{d})^n$</p><p><a href="https://ac.nowcoder.com/acm/contest/22769/E">公约数之和加强版</a></p><p>$\sum_{a=1}<sup>k\sum_{b}</sup>k\dots.gcd(a,b,\dots)$</p><p><a href="https://ac.nowcoder.com/acm/contest/22769/D">LCMS</a></p><p>和式可以变换为 $\sum_{i=1}<sup>n\sum_{j=1}</sup>nlcm(A_i,A_j)$</p><p>$f(n)=\sum_{i=1}<sup>n\sum_{j=1}</sup>n(A_i\times A_j)[gcd(i,j)==n]\F(d’)=\sum_{d’|d}f(d)=\sum_{d’|d}\sum_{i=1}<sup>n[\frac{A_i}{d}]\sum_{j=1}</sup>n[\frac{A_j}{d}] \上面的式子是比较好算的，交叉相乘为和的乘积 \ 反演\to f(n)=\sum_{n|d}F(d)\mu(\frac{d}{n})\ans=\sum_{d=1}^n\frac{1}{d}f(d)$</p><p><a href="https://www.luogu.com.cn/problem/P3911">最小公倍数之和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>(N<span class="number">-10</span>);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        sum%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    n=mx;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="comment">//两个因数都是i的倍数</span></span><br><span class="line">        <span class="comment">//枚举i的倍数为j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            F[i]+=cnt[j]*j;</span><br><span class="line">            F[i]%=p;</span><br><span class="line">        &#125;</span><br><span class="line">        F[i]*=F[i];</span><br><span class="line">        F[i]%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="comment">//公约数为i的方案数，计算反演式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=i;d&lt;=n;d+=i)&#123;</span><br><span class="line">            <span class="comment">//mu[d/i]可能为负</span></span><br><span class="line">            f[i]=(f[i]+F[d]*mu[d/i]%p+p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+f[i]*inv[i]%p+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans-sum+p)%p;</span><br><span class="line">    ans=ans*inv[<span class="number">2</span>]%p;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分块优化">分块优化</h4><p><a href="https://www.luogu.com.cn/problem/P3455">ZAP Queries</a></p><p>$\sum\sum[gcd(i,j)=d]$ 显然是非常好计算的，但是在多case的情况下，如果不进行优化很容易超时</p><p>优化前</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=d;i&lt;=<span class="built_in">min</span>(a,b);i+=d)&#123;</span><br><span class="line">    F[i]=(a/i)*(b/i);</span><br><span class="line">    ans+=F[i]*mu[i/d];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现F[i]其实可以分块来做，在一定区间内，F[i]的值是不变的，统计莫比乌斯函数区间和即可</p><p>$f(d)=\sum_{d|d’}F(d’)*\mu(\frac{d’}{n})=\sum_{d|d’}\mu(\frac{d’}{d})\frac{a}{d’}\frac{b}{d’}$</p><p>$t=\frac{d’}{d};;ans=\sum_{t}\mu(t)\frac{a}{dt}\frac{b}{dt}$ t时枚举量，实际上除数是a/d,b/d</p><p>$=\sum_{t}\mu(t)\frac{\frac{a}{d}}{t}\frac{\frac{d}{d}}{t}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="built_in">min</span>(a/d,b/d);l=r<span class="number">+1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(a/d/(a/d/l),b/d/(b/d/l));</span><br><span class="line">    ans+=(a/(l*d))*(b/(l*d))*(mu[r]-mu[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a/=d,b/=d;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="built_in">min</span>(a,b);l=r<span class="number">+1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">min</span>(a/(a/l),b/(b/l));</span><br><span class="line">    ans+=(a/l)*(b/l)*(sum[r]-sum[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3312">数表</a></p><p>$\sum_{i=1}<sup>n\sum_{j=1}</sup>m[\varphi(\gcd(i,j))&lt;=a] \quad \varphi(n)=\sum_{d|n}d$</p><p>$\sum_{\varphi(d)\le a}\varphi(d)f(d);;,f(d)=\sum_{n|d}F(d)\mu(\frac{d}{n})$</p><p>$\varphi(d’)\sum_{d’|d}\mu(\frac{d}{n})\frac{n}{d}\frac{n}{d}$ 不需要确保枚举量是d的倍数，使用树状数组求前面一部分前缀和，只有d的倍数才会被添加到树状数组中</p><p>离线查找答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录1e5以下的数据和约数和</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; o)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;o.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QUERY</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,a,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> QUERY&amp; o)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;o.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">min</span>(n,m),ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=t;l=r<span class="number">+1</span>)&#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">        <span class="comment">//query只会查到[l,r]区间内d的倍数的位置</span></span><br><span class="line">        ans+=(<span class="built_in">query</span>(r)-<span class="built_in">query</span>(l<span class="number">-1</span>))*(n/l)*(m/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// de(&quot;\n\n&quot;);</span></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin&gt;&gt;Q[i].n&gt;&gt;Q[i].m&gt;&gt;Q[i].a;</span><br><span class="line">        Q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+100001</span>);</span><br><span class="line">    <span class="built_in">sort</span>(Q<span class="number">+1</span>,Q<span class="number">+1</span>+q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(b[j].sum&lt;=Q[i].a <span class="keyword">and</span> j&lt;=<span class="number">1e5</span>)&#123;</span><br><span class="line">            <span class="comment">//将满足条件的约数和的倍数塞入到树状数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d=b[j].val;d&lt;=<span class="number">1e5</span>;d+=b[j].val)&#123;</span><br><span class="line">                <span class="built_in">add</span>(d,b[j].sum*mu[d/b[j].val]);  </span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        ans[Q[i].id]=<span class="built_in">solve2</span>(Q[i].n,Q[i].m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]&lt;<span class="number">0</span>) ans[i]+=<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筛法和积性函数</title>
      <link href="/2025/04/26/%E7%AD%9B%E6%B3%95%E5%92%8C%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/26/%E7%AD%9B%E6%B3%95%E5%92%8C%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="线性筛筛质数">线性筛筛质数</h4><p>线性筛为什么可以做到线性，它让每个合数只被<strong>最小的质因数</strong>筛选一次而不发生重复筛选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) pri[++cnt]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> pri[j]*i&lt;=<span class="number">1e8</span>;j++)&#123;</span><br><span class="line">        <span class="type">int</span> m=i*pri[j];</span><br><span class="line">        vis[m]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//说明pri[j]是i的最小质因数，同样是被筛数m的最小质因数，所以再后面的数就应该由pri[j]筛掉，而不是j++</span></span><br><span class="line">        <span class="comment">//那么6*3=18应该等到i=9是被pri[j]=2筛掉，所以i=6时遇到pri[j]=2就可以停止了</span></span><br><span class="line">        <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛求约数个数">线性筛求约数个数</h4><p>$$n=\prod_{i=1}<sup>sp_i</sup>{\alpha_i}\qquad ans=\prod_{i=1}^s(\alpha_i+1)$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>,d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">1e7</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            a[i]=<span class="number">1</span>;d[i]=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> i*pri[j]&lt;=<span class="number">1e7</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pri[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                a[m]=a[i]<span class="number">+1</span>;</span><br><span class="line">                d[m]=d[i]/a[m]*(a[m]<span class="number">+1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[m]=<span class="number">1</span>;</span><br><span class="line">                d[m]=d[i]*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛求约数和">线性筛求约数和</h4><p>$n=\prod_{i=1}<sup>sp_i</sup>{\alpha_i}\qquad (n)=\prod_{i=1}<sup>s\sum_{j=0}</sup>{\alpha_i}p_i^j$</p><blockquote><p>a[i]是最小质因数的约数和</p><p>d[i]是函数值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">1e7</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            a[i]=d[i]=i<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> i*pri[j]&lt;=<span class="number">1e7</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pri[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                a[m]=a[i]*p[j]<span class="number">+1</span>;</span><br><span class="line">                d[m]=d[i]/a[i]*a[m]</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[m]=p[j]<span class="number">+1</span>;</span><br><span class="line">                d[m]=d[i]*a[m];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛求莫比乌斯函数">线性筛求莫比乌斯函数</h4><p>莫比乌斯函数：</p><p>包含相同质因子为0</p><p>不同质因数为偶数个为1，奇数为-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">1e7</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> i*pri[j]&lt;=<span class="number">1e7</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pri[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                mu[m]=<span class="number">0</span>;s</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//比i多了一个质因数，奇偶互换0不变，所以取反</span></span><br><span class="line">                mu[m]=-mu[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="莫比乌斯反演">莫比乌斯反演</h5><p>设任意算术函数f, 其和函数为 $F(n)=\sum_{d|n}f(d)$ 即n的所有正因数的函数和称为和函数</p><p>莫比乌斯函数就是<mark>和函数到原函数的反向过程</mark> $f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})$</p><h4 id="线性筛与积性函数">线性筛与积性函数</h4><p>其实上诉问题，因子和$(n)=\sum_{d|n}d$ 和约数个数 $(n)=\sum_{d|n}1$都是积性函数</p><p>积性函数？对于互为质数的正整数p,q有 $(p<em>q)=(p)</em>(q)$</p><p><mark>积性函数都可以用线性筛求解1~n的所有函数值</mark></p><p>O(n)求1~n的欧拉函数是一个比较简单但直观的例子，所以线性筛也被称为欧拉筛</p><p>欧拉函数</p><p>$n=\prod_{i=1}<sup>sp_i</sup>{\alpha_i} \quad (n)=n\prod(1-\frac{1}{p_i})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//单独考虑质数的情况</span></span><br><span class="line">            pr[++cnt]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> pr[j]&lt;=n/i;j++)&#123;</span><br><span class="line">            <span class="type">int</span> m=i*pr[j];</span><br><span class="line">            vis[m]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//需要特别判断pq不互质的情况的</span></span><br><span class="line">            <span class="keyword">if</span>(i%pr[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//没有出现新的质因数p，就扩大到m就行</span></span><br><span class="line">                phi[m]=phi[i]*pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现了新的质因数</span></span><br><span class="line">                phi[m]=phi[i]*phi[pr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://ac.nowcoder.com/acm/contest/22769/B">完全积性函数 华华给月月出题</a></p><blockquote><p>幂函数对于任何的p,q都满足$(p<em>q)=p</em>q$ 被称为完全积性函数，不需要单独考虑遍历值不为最小质因数的情况</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">        <span class="comment">//单独考虑一下质数就行</span></span><br><span class="line">        pri[++cnt]=i;</span><br><span class="line">        f[i]=<span class="built_in">qpow</span>(i,n,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt <span class="keyword">and</span> pri[j]&lt;=n/i;j++)&#123;</span><br><span class="line">        vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//通过乘性关系递推</span></span><br><span class="line">        f[i*pri[j]]=f[i]*f[pri[j]]%p;</span><br><span class="line">        <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="杜教筛">杜教筛</h4><p>求积性函数的前缀和</p><p>用来调整每个词对损失的贡献，减对于高频词语的过分关注，更好的处理停用词等</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
